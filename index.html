<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Il Rituale ‚Äî Combinazione di Simboli</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@700&display=swap');

  :root{
    --bg:#050505; --fg:#e6e6e6; --muted:#9aa0a6;
    --accent:#2bff88; --accent2:#6bffda;
    --card:#0d0d0d; --ok:#22c55e; --err:#ff4d4d;
  }
  *{box-sizing:border-box}
  html,body{margin:0;background:radial-gradient(circle at 50% 15%, #111 0%, #000 80%);color:var(--fg);font-family:'Cinzel Decorative', serif}
  .page{max-width:1600px;margin:0 auto;padding:clamp(12px,2vw,24px);display:flex;flex-direction:column;align-items:center;text-align:center}

  /* HERO dimezzata */
  .hero{width:100%;max-width:min(500px,50vw);margin:0 auto clamp(10px,2vw,18px)}
  .hero img{width:100%;height:auto;display:block;border-radius:10px}
  .hero-fallback{width:100%;padding:clamp(16px,2vw,28px);border:2px dashed rgba(43,255,136,.35);border-radius:10px;color:var(--accent2)}

  h1{font-size:clamp(24px,5vw,42px);margin:clamp(8px,1.5vw,12px) 0;color:var(--accent);text-shadow:0 0 12px var(--accent),0 0 28px var(--accent2);letter-spacing:.06em}
  .sub{color:var(--muted);margin:0 0 clamp(12px,2vw,18px);font-size:clamp(14px,2vw,18px)}

  /* COMBINAZIONE */
  .panel{display:grid;grid-template-columns:repeat(auto-fit,minmax(min(220px,42vw),1fr));gap:clamp(12px,2vw,20px);width:100%;max-width:min(1200px,96vw);padding:clamp(12px,2vw,16px);border-radius:16px;background:rgba(20,20,20,.85);box-shadow:0 0 40px rgba(43,255,136,.25),inset 0 0 20px rgba(43,255,136,.15)}
  .slot{background:radial-gradient(300px 300px at 50% 30%, rgba(43,255,136,.08), transparent 70%), var(--card);border:2px solid rgba(43,255,136,.3);border-radius:16px;padding:clamp(8px,1.8vw,12px);display:flex;align-items:center;justify-content:center;gap:clamp(8px,1.5vw,10px);min-height:clamp(200px,28vw,320px);box-shadow:inset 0 0 20px rgba(43,255,136,.15)}
  .symbol{flex:1;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.6);border:1px solid rgba(43,255,136,.4);box-shadow:0 0 20px rgba(43,255,136,.15),inset 0 0 15px rgba(43,255,136,.1);border-radius:12px;overflow:hidden}
  .symbol img{width:100%;height:100%;max-width:clamp(160px,22vw,280px);max-height:clamp(160px,22vw,280px);object-fit:contain}
  .fallback{color:var(--accent2);font-size:.92rem;padding:6px;text-align:center}
  .arrow{width:clamp(36px,4.5vw,44px);height:clamp(36px,4.5vw,44px);display:flex;align-items:center;justify-content:center;font-size:clamp(18px,2.5vw,20px);cursor:pointer;color:var(--fg);background:rgba(30,30,30,.8);border:1px solid rgba(43,255,136,.3);border-radius:8px}
  .arrow:hover{background:rgba(43,255,136,.15)}
  .action{margin:clamp(12px,2vw,16px) 0;display:flex;gap:clamp(8px,1.5vw,12px);justify-content:center}
  button{appearance:none;border:0;cursor:pointer;border-radius:8px;padding:10px 16px;font-weight:700;font-size:1rem;background:rgba(30,30,30,.9);color:var(--fg);border:2px solid rgba(43,255,136,.3);font-family:'Cinzel Decorative',serif}
  button:hover{background:rgba(43,255,136,.15)}
  .msg{min-height:28px;font-size:1.1rem;margin-top:6px}
  .success{color:var(--ok)} .fail{color:var(--err)}
  .footer{margin-top:clamp(12px,2vw,18px);color:var(--accent2);font-size:.95rem}

  /* RITUALE */
  #rituale{display:none;width:100%;max-width:min(1100px,96vw);margin:clamp(16px,2.5vw,24px) auto 0}
  .rituale-text{margin:12px auto 8px;line-height:1.45;color:var(--fg);font-size:clamp(14px,2vw,18px)}
  .rit-title{font-size:clamp(22px,4vw,36px);margin:8px 0 12px;color:var(--accent);text-shadow:0 0 10px var(--accent),0 0 24px var(--accent2);letter-spacing:.08em}

  .ritual-wrap{display:flex;align-items:center;justify-content:center;gap:16px;margin-top:8px}
  .rit-gif{width:140px;height:140px;object-fit:cover;border-radius:8px;box-shadow:0 0 16px rgba(43,255,136,.25)}
  @media (max-width:900px){.rit-gif{display:none}}

  .pentacolo{position:relative;width:min(90vw,600px);height:min(90vw,600px);margin:0 auto 24px}
  .pentacolo svg{transform:rotate(180deg)}

  /* campi SUL pentacolo: sopra / centro / sotto */
  .rit-field{position:absolute;transform:translate(-50%,-50%)}
  .rf-top    {left:50%; top:22%;  width:66%;}
  .rf-mid    {left:50%; top:50%;  width:60%;}
  .rf-bottom {left:50%; top:78%;  width:66%;}
  .rit-field input{width:100%;padding:10px 12px;border-radius:10px;border:2px solid rgba(43,255,136,.35);background:rgba(10,10,10,.85);color:var(--fg);font-size:clamp(14px,2vw,16px)}
  .rit-btn{position:absolute;left:50%;top:62%;transform:translate(-50%,-50%)}
  .rit-msg{min-height:20px;margin-top:8px;font-size:1rem}

  @media (max-width:700px){
    .rf-top   {left:50%; top:106%; width:92%;}
    .rf-mid   {left:50%; top:124%; width:92%;}
    .rf-bottom{left:50%; top:142%; width:92%;}
    .rit-btn  {top:160%;}
  }

  /* GIOCO */
  #game{display:none;width:100%;max-width:min(960px,96vw);margin:28px auto 0;text-align:center}
  #game h2{margin:8px 0 6px;font-size:clamp(20px,4vw,28px);color:var(--accent);text-shadow:0 0 10px var(--accent)}
  #goal{color:var(--muted); margin-bottom:8px}
  #canvasWrap{background:#000;border:2px solid rgba(43,255,136,.3);border-radius:10px;padding:8px; position:relative;}
  canvas{display:block;width:100%;height:auto;background:#000}
  .hud{color:var(--muted);margin-top:8px;font-size:clamp(14px,2vw,16px)}
  .score{color:var(--accent2);margin-left:6px}
  .loading{color:var(--accent2); margin:8px 0}

  /* HUD punteggio + cuori + carica volo */
  .scoreHud{
    position:absolute; left:8px; top:8px;
    padding:6px 10px; font-weight:700;
    background:rgba(0,0,0,.55);
    border:1px solid rgba(43,255,136,.35);
    border-radius:8px; color:var(--accent2);
    text-shadow:0 0 8px rgba(43,255,136,.35);
    user-select:none; pointer-events:none;
  }
  .livesHud{
    position:absolute; right:8px; top:8px;
    display:flex; gap:6px; align-items:center;
    background:rgba(0,0,0,.35);
    border:1px solid rgba(43,255,136,.25);
    border-radius:8px; padding:4px 6px;
    user-select:none; pointer-events:none;
  }
  .livesHud img{ width:18px; height:18px; image-rendering:auto; }

  .chargeLabel{
    position:absolute; left:50%; transform:translateX(-50%);
    top:28px; color:var(--muted); font-size:12px; user-select:none;
  }
  .chargeHud{
    position:absolute; left:50%; transform:translateX(-50%);
    top:44px; width:180px; height:10px;
    background:rgba(255,255,255,.08); border:1px solid rgba(43,255,136,.35); border-radius:999px;
    overflow:hidden; user-select:none;
  }
  .chargeFill{height:100%; width:0%; background:linear-gradient(90deg, #2bff88, #6bffda)}

  /* Overlay fine partita */
  .overlayMsg{
    position:absolute; inset:0;
    display:none; align-items:center; justify-content:center;
    background:rgba(0,0,0,.45);
    pointer-events:none;
  }
  .overlayMsg .box{
    padding:14px 18px; border-radius:12px; background:rgba(0,0,0,.75);
    border:1px solid rgba(43,255,136,.35); color:#fff; font-weight:700;
    text-shadow:0 0 10px rgba(43,255,136,.35);
    font-size:clamp(16px,2.2vw,22px); max-width:80%; text-align:center;
  }

  .blink{ animation: bl 0.12s linear infinite alternate; }
  @keyframes bl { from{opacity:1} to{opacity:.35} }
</style>
</head>
<body><h1>diominchia</h1>
  <main class="page">
    <!-- HERO -->
    <div class="hero" id="heroBox"></div>

    <h1>Combinazione di Simboli</h1>
    <p class="sub">Allinea i quattro simboli corretti per risvegliare l'oscuro portale.</p>

    <section class="panel" id="panel"></section>

    <div class="action">
      <button id="shuffle">Mescola</button>
      <button id="check">Verifica</button>
    </div>
    <div id="message" class="msg"></div>
    <div class="footer" id="hintBox"></div>

    <!-- RITUALE -->
    <section id="rituale">
      <p class="rituale-text" id="ritText"></p>
      <div class="rit-title">Inizia il Rituale</div>

      <div class="ritual-wrap">
        <img class="rit-gif" src="https://media1.giphy.com/media/v1.Y2lkPTc5MGI3NjExeHlhOXY3M3hsb3cxdnlkbDRsM3M3c2tpNHA2ejFoaHFudzE4ZDlwZyZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/9zOiTQ7RPxU7C/giphy.gif" alt="fuoco sinistro">
        <div class="pentacolo">
          <svg viewBox="0 0 100 100" width="100%" height="100%" aria-hidden="true" style="position:absolute;left:0;top:0;filter:drop-shadow(0 0 10px rgba(43,255,136,.35));">
            <circle cx="50" cy="50" r="45" fill="none" stroke="rgba(43,255,136,.35)" stroke-width="2"/>
            <polygon points="50,6 61,40 96,40 67,60 78,94 50,73 22,94 33,60 4,40 39,40" fill="none" stroke="rgba(43,255,136,.55)" stroke-width="2"/>
          </svg>
          <div class="rit-field rf-top"><input id="f1" type="text" placeholder="Ingrediente (sopra)"></div>
          <div class="rit-field rf-mid"><input id="f2" type="text" placeholder="Ingrediente (centro)"></div>
          <div class="rit-field rf-bottom"><input id="f3" type="text" placeholder="Ingrediente (sotto)"></div>
          <button class="rit-btn" id="completeBtn">Completa</button>
        </div>
        <img class="rit-gif" src="https://media1.giphy.com/media/v1.Y2lkPTc5MGI3NjExeHlhOXY3M3hsb3cxdnlkbDRsM3M3c2tpNHA2ejFoaHFudzE4ZDlwZyZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/9zOiTQ7RPxU7C/giphy.gif" alt="fuoco destro">
      </div>

      <div id="ritMsg" class="rit-msg"></div>
    </section>

    <!-- GIOCO -->
    <section id="game">
      <h2>La Corsa della Zucca</h2>
      <div id="goal">Obiettivo: raggiungi un punteggio di <strong>666</strong> per superare il livello.</div>
      <div id="canvasWrap">
        <div id="scoreHud" class="scoreHud">0</div>
        <div class="chargeLabel">Carica volo</div>
        <div id="chargeHud" class="chargeHud"><div id="chargeFill" class="chargeFill"></div></div>
        <div id="livesHud" class="livesHud"></div>
        <div id="overlayMsg" class="overlayMsg"><div class="box" id="overlayBox"></div></div>
        <canvas id="runner" width="900" height="300"></canvas>
      </div>
      <div class="hud">Controlli: <strong>‚Üê</strong>/<strong>‚Üí</strong> muovi, <strong>SPAZIO</strong> o <strong>‚Üë</strong> salta (tieni premuto <strong>‚Üë</strong> per volo). Punteggio: <span class="score" id="score">0</span></div>
      <div class="loading" id="loadingMsg">Caricamento immagini‚Ä¶</div>
      <div class="cta" style="margin-top:10px"><button id="startGame">Avvia</button> <button id="restartGame" style="display:none">Riprova</button></div>
    </section>
  </main>

<script>
document.addEventListener('DOMContentLoaded', () => {
  /* HERO con fallback */
  const hero = document.getElementById('heroBox');
  const b = new Image(); b.src='media/home.png?v=1'; b.alt='Il Rituale';
  b.onload=()=>hero.appendChild(b);
  b.onerror=()=>{const fb=document.createElement('div');fb.className='hero-fallback';fb.textContent='MANCANTE: media/home.png';hero.appendChild(fb);};

  /* SIMBOLI */
  const SYMBOLS = Array.from({length:12},(_,i)=>({id:String(i+1),src:`./media/${i+1}.png?v=1`}));
  const TARGET = atob("MSwyLDMsNA==").split(","); // "1,2,3,4"

  const HINTS=[
    "Spesso gli oggetti dei rituali si nascondono nelle stanze pi√π buie.",
    "Le scope delle streghe nascondono sempre qualcosa.",
    "Una volta ho sentito la storia di una \"casa del dolore\", forse si parlava di qualcosa di interessante?"
  ];
  document.getElementById('hintBox').textContent="Suggerimento: "+HINTS[Math.floor(Math.random()*HINTS.length)];

  const panel=document.getElementById('panel'), message=document.getElementById('message'),
        rituale=document.getElementById('rituale'), ritText=document.getElementById('ritText'),
        gameSec=document.getElementById('game');

  let state=[], ritualeShown=false;

  function renderSymbol(el,idx){
    el.innerHTML=''; const img=new Image(); img.src=SYMBOLS[idx].src; img.alt=`simbolo ${idx+1}`;
    img.onerror=()=>{el.innerHTML=`<div class="fallback">MANCANTE: ${SYMBOLS[idx].src}</div>`}; el.appendChild(img);
  }
  function createSlot(i){
    const wrap=document.createElement('div'); wrap.className='slot';
    const L=document.createElement('div'); L.className='arrow'; L.textContent='‚óÄ';
    const S=document.createElement('div'); S.className='symbol';
    const R=document.createElement('div'); R.className='arrow'; R.textContent='‚ñ∂';
    wrap.append(L,S,R);
    state[i]=Math.floor(Math.random()*SYMBOLS.length); renderSymbol(S,state[i]);
    L.addEventListener('click',()=>{state[i]=(state[i]-1+SYMBOLS.length)%SYMBOLS.length;renderSymbol(S,state[i]);message.textContent='';});
    R.addEventListener('click',()=>{state[i]=(state[i]+1)%SYMBOLS.length;renderSymbol(S,state[i]);message.textContent='';});
    return wrap;
  }
  function build(){panel.innerHTML='';state=[];for(let i=0;i<4;i++)panel.appendChild(createSlot(i));}
  function shuffle(){for(let i=0;i<4;i++)state[i]=Math.floor(Math.random()*SYMBOLS.length);
    [...panel.children].forEach((slotEl,i)=>renderSymbol(slotEl.querySelector('.symbol'),state[i]));message.textContent='';}
  function check(){
    const picked=state.map(idx=>SYMBOLS[idx].id);
    const ok=picked.length===TARGET.length && picked.every((id,i)=>id===TARGET[i]);
    if(ok){
      message.className='msg success'; message.textContent='';
      if(!ritualeShown){
        ritText.textContent="Bene, molto bene. Quindi Herr Knock ti ha insegnato molto. Per procedere con il rituale √® fondamentale trovare i tre ingredienti per Evocare il Principe delle Tenebre. Credo che tu possa trovarli all'interno del server, ma non sar√† facile.";
        rituale.style.display='block'; rituale.scrollIntoView({behavior:'smooth'}); ritualeShown=true;
      }
    } else { message.className='msg fail'; message.textContent='sbagliato'; }
  }
  document.getElementById('shuffle').onclick=shuffle;
  document.getElementById('check').onclick=check;
  build();

  /* ===== RITUALE ‚Äî ordine libero ===== */
  const norm=(s)=>s.normalize('NFD').replace(/\p{Diacritic}/gu,'').toLowerCase().replace(/[^\p{L}\p{N}\s]/gu,'').replace(/\s+/g,' ').trim();
  function classify(text){
    const v=norm(text); if(!v) return null;
    const has=(...ws)=>ws.every(w=>v.includes(w));
    if(v.includes('candela') && (v.includes('nera')||v.includes('nero'))) return 'CANDLE';
    const rust=v.includes('arrugginito')||v.includes('arrugginita')||v.includes('ossidato')||v.includes('ossidata')||v.includes('ruggine');
    if(v.includes('coltello') && rust && has('simbolo','bestia')) return 'KNIFE';
    const peli=v.includes('peli')||v.includes('pelo'); const pub=v.includes('pubici')||v.includes('pubico');
    const fem=v.includes('femmina')||v.includes('donna');
    if(peli && pub && v.includes('zombie') && fem) return 'HAIR';
    return null;
  }
  function submitRitual(){
    const types=[classify(f1.value), classify(f2.value), classify(f3.value)];
    const set=new Set(types.filter(Boolean));
    const ok=set.has('CANDLE') && set.has('KNIFE') && set.has('HAIR') && types.every(t=>t!==null);
    const box=document.getElementById('ritMsg');
    if(ok){
      box.className='rit-msg success';
      box.textContent='Il cerchio si illumina‚Ä¶ il portale si apre!';
      gameSec.style.display='block'; gameSec.scrollIntoView({behavior:'smooth'});
    }else{
      box.className='rit-msg fail';
      box.textContent='La formula non risponde. Forse hai sbagliato gli ingredienti...';
    }
  }
  const f1=document.getElementById('f1'), f2=document.getElementById('f2'), f3=document.getElementById('f3');
  document.getElementById('completeBtn').onclick=submitRitual;
  ;[f1,f2,f3].forEach(el=>el.addEventListener('keydown',e=>{ if(e.key==='Enter') submitRitual(); e.stopPropagation(); }));

  /* =========================
     MINIGIOCO ‚Äî Pumpkin Runner (volo fix + spawn random sfalsati + overlay)
     ========================= */
  const TARGET_SCORE = 666;

  // Canvas & UI
  const cvs = document.getElementById('runner'), ctx = cvs.getContext('2d');
  const scoreHudEl = document.getElementById('scoreHud');
  const scoreEl = document.getElementById('score');
  const livesHud = document.getElementById('livesHud');
  const chargeFill = document.getElementById('chargeFill');
  const overlay = document.getElementById('overlayMsg'), overlayBox=document.getElementById('overlayBox');
  const startBtn = document.getElementById('startGame'),
        restartBtn = document.getElementById('restartGame'),
        loadingMsg = document.getElementById('loadingMsg');

  // Immagini
  const playerImg = new Image(); playerImg.src = 'media/zucca.png?v=1';
  const heartImgSrc = 'media/heart.png';
  const bgImg = new Image(); bgImg.src = 'media/sfondo.png';
  const monsterNames = ['mostro1.png','mostro2.png','mostro3.png','mostro4.png'];
  const monsterImgs = monsterNames.map(n => { const im=new Image(); im.src='media/'+n+'?v=1'; return im; });

  function preload(imgs){
    const toLoad = imgs.filter(img => !img.complete || img.naturalWidth===0);
    if(toLoad.length===0) return Promise.resolve();
    return Promise.allSettled(toLoad.map(img => new Promise(res=>{
      img.addEventListener('load', res, {once:true});
      img.addEventListener('error', res, {once:true});
    })));
  }

  // Stato di gioco
  let running=false, gameOver=false, score=0, lastSpawn=0, lastTs=null;

  // Velocit√† mondo (gi√† approvata)
  let speed = 0.8;
  const MAX_SPEED = 4.2;
  const ACCEL_PER_SEC = 0.04;
  const ACCEL_RAMP_TIME = 90;
  let elapsedRunTime = 0;

  // Sfondo parallax
  let bgOffset = 0;
  const BG_PARALLAX = 0.42;

  const ground = cvs.height - 40;
  const airLaneY = ground - 150;

  // Player con movimento orizzontale
  const player = { x:120, y:0, w:44, h:44, vx:0, vy:0, onGround:true };
  player.y = ground - player.h;

  // Oggetti
  const obstacles=[];   // {x,y,w,h,img,type:'ground'|'air'}
  const pickups=[];     // {x,y,type:'candle'|'heart', w,h, emoji}
  const spawnQueue=[];  // {type, delay}

  // Vite
  const MAX_LIVES = 3;
  let lives = MAX_LIVES;
  let invuln = 0;

  function renderLives(){
    livesHud.innerHTML='';
    for(let i=0;i<MAX_LIVES;i++){
      const im = document.createElement('img');
      im.src = heartImgSrc;
      if(i >= lives){ im.style.filter='grayscale(1) brightness(0.7)'; im.style.opacity='0.5'; }
      livesHud.appendChild(im);
    }
  }

  // Fisica salto + movimento + volo
  const GRAVITY = 0.52;            // per-frame
  const BASE_JUMP_VY = -11.0;
  const SHORT_CUT_VY = -3.0;
  const COYOTE_TIME = 0.14;
  const JUMP_BUFFER = 0.16;

  const MOVE_ACCEL = 0.20;
  const MOVE_ACCEL_AIR = 0.12;
  const MAX_VX = 3.0;
  const FRICTION = 0.86;

  // Volo (tenendo ‚Üë)
  let upHeld = false;
  const MAX_FLIGHT_ENERGY = 0.5;   // met√† carica massima
  let flightEnergy = MAX_FLIGHT_ENERGY;
  const FLIGHT_DRAIN = 0.6;        // /s mentre voli
  const FLIGHT_RECHARGE = 0.18;    // /s ricarica lenta
  const FLIGHT_BOOST = 0.70;       // spinta per-frame (compensa gravit√† 0.52)
  const FLIGHT_CLIMB_CAP = -4.2;   // velocit√† massima di salita (pi√π negativo = pi√π su)
  function updateChargeBar(){
    const pct = Math.round((flightEnergy / MAX_FLIGHT_ENERGY)*100);
    chargeFill.style.width = Math.max(0, Math.min(100, pct)) + '%';
  }

  let coyoteTimer = 0;
  let jumpBufferTimer = 0;
  let jumpHeld = false;
  let leftHeld = false;
  let rightHeld = false;

  function requestJump(){ jumpBufferTimer = JUMP_BUFFER; }

  function doDirectionalJump(){
    let vy = BASE_JUMP_VY;
    let impulseX = 0;
    if(rightHeld && !leftHeld){
      vy = BASE_JUMP_VY * 1.05;  // pi√π alto e lungo in avanti
      impulseX = 2.8;
    } else if(leftHeld && !rightHeld){
      vy = BASE_JUMP_VY * 0.62;  // saltello corto all'indietro
      impulseX = -2.1;
    }
    player.vy = vy;
    player.vx += impulseX;
    player.vx = Math.max(-MAX_VX, Math.min(MAX_VX, player.vx));
    player.onGround = false;
    coyoteTimer = 0;
    jumpBufferTimer = 0;
  }

  function tryPerformJump(){
    if ((coyoteTimer > 0 || player.onGround) && jumpBufferTimer > 0){
      doDirectionalJump();
    }
  }

  // Spawner
  function spawnObstacleOfType(type){
    const img = monsterImgs[Math.floor(Math.random()*monsterImgs.length)];
    const w = 46 + Math.random()*10;
    const ratio = (img && img.naturalWidth) ? (img.naturalHeight/img.naturalWidth) : 1.2;
    const h = w * ratio;
    const y = (type==='ground') ? (ground-h) : (airLaneY - h/2);
    obstacles.push({ x:cvs.width+10, y, w, h, img, type });
  }

  function shuffleArray(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }

  function queuePattern(currentScore){
    // Quanti?
    let counts = { air:0, ground:0 };
    if(currentScore > 600){ counts = {air:2, ground:2}; }
    else if(currentScore > 400){ counts = {air:2, ground:1}; }
    else if(currentScore > 200){ counts = {air:1, ground:1}; }
    else { counts = {air: (Math.random()<0.5?1:0), ground: (Math.random()<0.5?1:0)}; if(counts.air===0 && counts.ground===0) counts.ground=1; }

    // Crea lista tipi e randomizza ordine
    const types = [];
    for(let i=0;i<counts.air;i++) types.push('air');
    for(let i=0;i<counts.ground;i++) types.push('ground');
    shuffleArray(types);

    // Ritardi sfalsati casuali
    const BASE_GAP = 0.18;
    const JITTER = 0.10; // ¬±100ms
    const startOffset = Math.random()*0.20; // 0‚Äì200ms prima del primo spawn
    types.forEach((t, idx)=>{
      const delay = startOffset + idx*BASE_GAP + (Math.random()*2*JITTER - JITTER);
      spawnQueue.push({type:t, delay: Math.max(0, delay)});
    });
  }

  // Collezionabili
  const PICKUP_CHANCE = 0.20;
  const PICKUP_COOLDOWN = 4.0;
  let lastPickupTime = -Infinity;

  function spawnPickup(){
    const now = performance.now() / 1000;
    if(now - lastPickupTime < PICKUP_COOLDOWN) return false;

    const type = Math.random() < 0.5 ? 'candle' : 'heart';
    const lane = Math.random() < 0.5 ? 'air' : 'ground';
    const emoji = type === 'candle' ? 'üïØÔ∏è' : '‚ù§Ô∏è';
    const fontSize = 24;
    const w = fontSize, h = fontSize;
    const y = lane === 'ground' ? (ground - h - 6) : (airLaneY - h/2);

    pickups.push({ x:cvs.width+10, y, w, h, emoji, type });
    lastPickupTime = now;
    return true;
  }

  function drawPickup(p){
    ctx.font = "24px system-ui, Apple Color Emoji, Segoe UI Emoji, Noto Color Emoji";
    ctx.textBaseline = "top";
    ctx.fillText(p.emoji, p.x, p.y);
  }

  function drawImage(img, x,y,w,h){ if(img && img.complete && img.naturalWidth) ctx.drawImage(img,x,y,w,h); }

  // Background
  function drawBackground(){
    if(bgImg && bgImg.complete && bgImg.naturalWidth){
      const bw = bgImg.naturalWidth;
      const bh = bgImg.naturalHeight;
      const scale = cvs.height / bh;
      const drawW = bw * scale;
      bgOffset = (bgOffset - (speed * BG_PARALLAX)) % drawW;
      if(bgOffset < -drawW) bgOffset += drawW;
      for(let x=bgOffset; x < cvs.width + drawW; x += drawW){
        ctx.drawImage(bgImg, 0, 0, bw, bh, Math.floor(x), 0, Math.ceil(drawW), cvs.height);
      }
    } else {
      const g = ctx.createLinearGradient(0,0,0,cvs.height);
      g.addColorStop(0,'#020202'); g.addColorStop(1,'#0a0a0a');
      ctx.fillStyle=g; ctx.fillRect(0,0,cvs.width,cvs.height);
    }
  }

  function resetGame(){
    running=false; gameOver=false; score=0; lastTs=null; lastSpawn=0;
    overlay.style.display='none'; overlayBox.textContent='';
    obstacles.length=0; pickups.length=0; spawnQueue.length=0;

    speed=0.8; elapsedRunTime=0;
    flightEnergy = MAX_FLIGHT_ENERGY; updateChargeBar();

    player.x=120; player.y=ground-player.h; player.vx=0; player.vy=0; player.onGround=true;
    scoreHudEl.textContent='0'; scoreEl.textContent='0';
    coyoteTimer = 0; jumpBufferTimer = 0; jumpHeld = false; leftHeld=false; rightHeld=false; upHeld=false;
    invuln = 0; lives = MAX_LIVES; renderLives();
    cvs.classList.remove('blink');
    lastPickupTime = -Infinity;
  }

  function endGameSuccess(){
    gameOver = true; running = false;
    overlay.style.display='flex';
    overlayBox.style.color = 'var(--ok)';
    overlayBox.textContent = 'XXXX';
    restartBtn.style.display='inline-block';
    cvs.classList.remove('blink');
  }

  function endGameFailure(){
    gameOver = true; running = false;
    overlay.style.display='flex';
    overlayBox.style.color = 'var(--err)';
    overlayBox.textContent = 'Ritenta quante volte vuoi, tanto non ci riuscirai mai!';
    restartBtn.style.display='inline-block';
    cvs.classList.remove('blink');
  }

  function hitPlayer(){
    if(invuln > 0 || gameOver) return;
    lives -= 1; renderLives();
    invuln = 1.2;
    cvs.classList.add('blink');
    if(lives <= 0){ endGameFailure(); }
  }

  function loop(ts){
    if(!running) return;
    const delta = lastTs ? (ts-lastTs)/1000 : 0; lastTs = ts;
    elapsedRunTime += delta;

    // Velocit√† mondo
    const t = Math.min(1, elapsedRunTime / ACCEL_RAMP_TIME);
    const eased = t*t*(3 - 2*t);
    const targetSpeed = 0.8 + (MAX_SPEED - 0.8) * eased;
    speed += (targetSpeed - speed) * ACCEL_PER_SEC;

    // Punteggio
    score += (1.1 + (speed-0.8)*0.22) * delta;
    const shown = Math.floor(score);
    scoreHudEl.textContent = shown;
    scoreEl.textContent = shown;
    if(score >= TARGET_SCORE && !gameOver){ endGameSuccess(); }

    // Sfondo
    drawBackground();

    // piste
    ctx.strokeStyle='rgba(43,255,136,.3)';
    ctx.beginPath(); ctx.moveTo(0,ground+0.5); ctx.lineTo(cvs.width,ground+0.5); ctx.stroke();
    ctx.setLineDash([6,6]); ctx.beginPath(); ctx.moveTo(0,airLaneY+0.5); ctx.lineTo(cvs.width,airLaneY+0.5); ctx.stroke(); ctx.setLineDash([]);

    // spawn pattern/pickup
    const baseInterval = 2400 - speed*90;
    const jitter = 900 * Math.random();
    const interval = Math.max(1400, baseInterval + jitter);

    if(ts - lastSpawn > interval){
      lastSpawn = ts;

      if(score < TARGET_SCORE && Math.random() < PICKUP_CHANCE){
        if(!spawnPickup()){ queuePattern(score); }
      } else {
        queuePattern(score);
      }
    }

    // esegui coda spawn sfalsati
    for(let i=spawnQueue.length-1;i>=0;i--){
      spawnQueue[i].delay -= delta;
      if(spawnQueue[i].delay <= 0){
        spawnObstacleOfType(spawnQueue[i].type);
        spawnQueue.splice(i,1);
      }
    }

    // pickups
    for(let i=pickups.length-1;i>=0;i--){
      const p = pickups[i];
      p.x -= speed;
      drawPickup(p);
      if(p.x + p.w < 0){ pickups.splice(i,1); continue; }
      const padP = 8, padO = 4;
      const px=player.x+padP, py=player.y+padP, pw=player.w-2*padP, ph=player.h-2*padP;
      const ox=p.x+padO, oy=p.y+padO, ow=p.w-2*padO, oh=p.h-2*padO;
      if(px < ox + ow && px + pw > ox && py < oy + oh && py + ph > oy){
        if(p.type === 'candle'){ score += 50; }
        else if(p.type === 'heart'){ if(lives < MAX_LIVES){ lives += 1; renderLives(); } }
        pickups.splice(i,1);
      }
    }

    // ostacoli
    for(let i=obstacles.length-1;i>=0;i--){
      const o=obstacles[i];
      o.x -= speed;
      drawImage(o.img, o.x, o.y, o.w, o.h);
      if(o.x + o.w < 0) obstacles.splice(i,1);

      const padP = 10, padO = 12;
      const px=player.x+padP, py=player.y+padP, pw=player.w-2*padP, ph=player.h-2*padP;
      const ox=o.x+padO, oy=o.y+padO, ow=o.w-2*padO, oh=o.h-2*padO;
      if(px < ox + ow && px + pw > ox && py < oy + oh && py + ph > oy){ hitPlayer(); }
    }

    /* --- Fisica player --- */

    // input orizzontale
    const accel = player.onGround ? MOVE_ACCEL : MOVE_ACCEL_AIR;
    if(leftHeld && !rightHeld)  player.vx -= accel;
    else if(rightHeld && !leftHeld) player.vx += accel;
    else player.vx *= FRICTION;
    player.vx = Math.max(-MAX_VX, Math.min(MAX_VX, player.vx));

    player.x += player.vx;
    const minX = 20, maxX = cvs.width * 0.7;
    if(player.x < minX){ player.x = minX; player.vx = Math.max(0, player.vx); }
    if(player.x > maxX){ player.x = maxX; player.vx = Math.min(0, player.vx); }

    // gravit√†
    player.vy += GRAVITY;

    // volo (tenendo ‚Üë)
    if(upHeld && !player.onGround && flightEnergy > 0){
      player.vy -= FLIGHT_BOOST;                         // contrasta la gravit√† per-frame
      if(player.vy < FLIGHT_CLIMB_CAP) player.vy = FLIGHT_CLIMB_CAP; // cap salita
      flightEnergy = Math.max(0, flightEnergy - FLIGHT_DRAIN * delta);
      updateChargeBar();
    } else {
      // ricarica lenta
      flightEnergy = Math.min(MAX_FLIGHT_ENERGY, flightEnergy + FLIGHT_RECHARGE * delta);
      updateChargeBar();
    }

    player.y += player.vy;

    // atterraggio
    if(player.y + player.h >= ground){
      player.y = ground - player.h;
      if(!player.onGround){
        player.onGround = true;
        coyoteTimer = 0;
        tryPerformJump();
      } else {
        player.onGround = true;
      }
      if(player.vy > 0) player.vy = 0;
    } else {
      if(player.onGround){
        player.onGround = false;
        coyoteTimer = COYOTE_TIME;
      } else {
        coyoteTimer -= (delta);
      }
    }

    // salto variabile
    if(!jumpHeld && player.vy < SHORT_CUT_VY){
      player.vy = SHORT_CUT_VY;
    }

    // timers
    jumpBufferTimer -= delta;
    invuln -= delta;
    if(invuln <= 0){ invuln = 0; cvs.classList.remove('blink'); }

    // draw player
    if(!(invuln>0 && Math.floor(ts/60)%2===0)){
      drawImage(playerImg, player.x, player.y, player.w, player.h);
    }

    requestAnimationFrame(loop);
  }

  // Input tastiera
  window.addEventListener('keydown', async (e)=>{
    const tag=document.activeElement && document.activeElement.tagName;
    if(tag==='INPUT' || tag==='TEXTAREA') return;

    if(e.code==='ArrowLeft'){ leftHeld = true; }
    if(e.code==='ArrowRight'){ rightHeld = true; }
    if(e.code==='ArrowUp'){ upHeld = true; }

    if(e.code==='Space' || e.code==='ArrowUp'){
      e.preventDefault();
      if(gameOver){ resetGame(); await startGame(); return; }
      jumpHeld = true;
      if(!running){ await startGame(); requestJump(); }
      else { requestJump(); tryPerformJump(); }
    }
  });
  window.addEventListener('keyup', (e)=>{
    if(e.code==='ArrowLeft'){ leftHeld = false; }
    if(e.code==='ArrowRight'){ rightHeld = false; }
    if(e.code==='ArrowUp'){ upHeld = false; jumpHeld = false; }
    if(e.code==='Space'){ jumpHeld = false; }
  });

  // Touch/click sul canvas
  document.getElementById('runner').addEventListener('pointerdown', ()=>{
    if(gameOver){ resetGame(); startGame(); return; }
    if(!running){ startGame(); requestJump(); }
    else { jumpHeld = true; upHeld = true; requestJump(); tryPerformJump(); }
  });
  document.getElementById('runner').addEventListener('pointerup', ()=>{ jumpHeld=false; upHeld=false; });

  async function startGame(){
    loadingMsg.style.display='block';
    await preload([playerImg, bgImg, ...monsterImgs]);
    loadingMsg.style.display='none';

    if(!running){
      running = true; restartBtn.style.display='none'; requestAnimationFrame(loop);
    }
  }

  document.getElementById('startGame').onclick = startGame;
  document.getElementById('restartGame').onclick = ()=>{ resetGame(); startGame(); };

  // ready
  renderLives(); updateChargeBar();
});
</script>
</body>
</html>
