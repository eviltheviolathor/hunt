<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Il Rituale — Combinazione di Simboli</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@700&display=swap');

  :root{
    --bg:#050505; --fg:#e6e6e6; --muted:#9aa0a6;
    --accent:#2bff88; --accent2:#6bffda;
    --card:#0d0d0d; --ok:#22c55e; --err:#ff4d4d;
  }
  *{box-sizing:border-box}
  html,body{margin:0;background:radial-gradient(circle at 50% 15%, #111 0%, #000 80%);color:var(--fg);font-family:'Cinzel Decorative', serif}
  .page{max-width:1600px;margin:0 auto;padding:clamp(12px,2vw,24px);display:flex;flex-direction:column;align-items:center;text-align:center}

  /* HERO dimezzata */
  .hero{width:100%;max-width:min(500px,50vw);margin:0 auto clamp(10px,2vw,18px)}
  .hero img{width:100%;height:auto;display:block;border-radius:10px}
  .hero-fallback{width:100%;padding:clamp(16px,2vw,28px);border:2px dashed rgba(43,255,136,.35);border-radius:10px;color:var(--accent2)}

  h1{font-size:clamp(24px,5vw,42px);margin:clamp(8px,1.5vw,12px) 0;color:var(--accent);text-shadow:0 0 12px var(--accent),0 0 28px var(--accent2);letter-spacing:.06em}
  .sub{color:var(--muted);margin:0 0 clamp(12px,2vw,18px);font-size:clamp(14px,2vw,18px)}

  /* COMBINAZIONE */
  .panel{display:grid;grid-template-columns:repeat(auto-fit,minmax(min(220px,42vw),1fr));gap:clamp(12px,2vw,20px);width:100%;max-width:min(1200px,96vw);padding:clamp(12px,2vw,16px);border-radius:16px;background:rgba(20,20,20,.85);box-shadow:0 0 40px rgba(43,255,136,.25),inset 0 0 20px rgba(43,255,136,.15)}
  .slot{background:radial-gradient(300px 300px at 50% 30%, rgba(43,255,136,.08), transparent 70%), var(--card);border:2px solid rgba(43,255,136,.3);border-radius:16px;padding:clamp(8px,1.8vw,12px);display:flex;align-items:center;justify-content:center;gap:clamp(8px,1.5vw,10px);min-height:clamp(200px,28vw,320px);box-shadow:inset 0 0 20px rgba(43,255,136,.15)}
  .symbol{flex:1;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.6);border:1px solid rgba(43,255,136,.4);box-shadow:0 0 20px rgba(43,255,136,.15),inset 0 0 15px rgba(43,255,136,.1);border-radius:12px;overflow:hidden}
  .symbol img{width:100%;height:100%;max-width:clamp(160px,22vw,280px);max-height:clamp(160px,22vw,280px);object-fit:contain}
  .fallback{color:var(--accent2);font-size:.92rem;padding:6px;text-align:center}
  .arrow{width:clamp(36px,4.5vw,44px);height:clamp(36px,4.5vw,44px);display:flex;align-items:center;justify-content:center;font-size:clamp(18px,2.5vw,20px);cursor:pointer;color:var(--fg);background:rgba(30,30,30,.8);border:1px solid rgba(43,255,136,.3);border-radius:8px}
  .arrow:hover{background:rgba(43,255,136,.15)}
  .action{margin:clamp(12px,2vw,16px) 0;display:flex;gap:clamp(8px,1.5vw,12px);justify-content:center}
  button{appearance:none;border:0;cursor:pointer;border-radius:8px;padding:10px 16px;font-weight:700;font-size:1rem;background:rgba(30,30,30,.9);color:var(--fg);border:2px solid rgba(43,255,136,.3);font-family:'Cinzel Decorative',serif}
  button:hover{background:rgba(43,255,136,.15)}
  .msg{min-height:28px;font-size:1.1rem;margin-top:6px}
  .success{color:var(--ok)} .fail{color:var(--err)}
  .footer{margin-top:clamp(12px,2vw,18px);color:var(--accent2);font-size:.95rem}

  /* RITUALE */
  #rituale{display:none;width:100%;max-width:min(1100px,96vw);margin:clamp(16px,2.5vw,24px) auto 0}
  .rituale-text{margin:12px auto 8px;line-height:1.45;color:var(--fg);font-size:clamp(14px,2vw,18px)}
  .rit-title{font-size:clamp(22px,4vw,36px);margin:8px 0 12px;color:var(--accent);text-shadow:0 0 10px var(--accent),0 0 24px var(--accent2);letter-spacing:.08em}

  .ritual-wrap{display:flex;align-items:center;justify-content:center;gap:16px;margin-top:8px}
  .rit-gif{width:140px;height:140px;object-fit:cover;border-radius:8px;box-shadow:0 0 16px rgba(43,255,136,.25)}
  @media (max-width:900px){.rit-gif{display:none}}

  .pentacolo{position:relative;width:min(90vw,600px);height:min(90vw,600px);margin:0 auto 24px}
  .pentacolo svg{transform:rotate(180deg)}

  /* campi SUL pentacolo: sopra / centro / sotto */
  .rit-field{position:absolute;transform:translate(-50%,-50%)}
  .rf-top    {left:50%; top:22%;  width:66%;}
  .rf-mid    {left:50%; top:50%;  width:60%;}
  .rf-bottom {left:50%; top:78%;  width:66%;}
  .rit-field input{width:100%;padding:10px 12px;border-radius:10px;border:2px solid rgba(43,255,136,.35);background:rgba(10,10,10,.85);color:var(--fg);font-size:clamp(14px,2vw,16px)}
  .rit-btn{position:absolute;left:50%;top:62%;transform:translate(-50%,-50%)}
  .rit-msg{min-height:20px;margin-top:8px;font-size:1rem}

  @media (max-width:700px){
    .rf-top   {left:50%; top:106%; width:92%;}
    .rf-mid   {left:50%; top:124%; width:92%;}
    .rf-bottom{left:50%; top:142%; width:92%;}
    .rit-btn  {top:160%;}
  }

  /* GIOCO */
  #game{display:none;width:100%;max-width:min(960px,96vw);margin:28px auto 0;text-align:center}
  #game h2{margin:8px 0 6px;font-size:clamp(20px,4vw,28px);color:var(--accent);text-shadow:0 0 10px var(--accent)}
  #goal{color:var(--muted); margin-bottom:8px}
  #canvasWrap{background:#000;border:2px solid rgba(43,255,136,.3);border-radius:10px;padding:8px; position:relative;}
  canvas{display:block;width:100%;height:auto;background:#000}
  .hud{color:var(--muted);margin-top:8px;font-size:clamp(14px,2vw,16px)}
  .score{color:var(--accent2);margin-left:6px}
  .loading{color:var(--accent2); margin:8px 0}

  /* HUD punteggio + cuori + carica volo */
  .scoreHud{
    position:absolute; left:8px; top:8px;
    padding:6px 10px; font-weight:700;
    background:rgba(0,0,0,.55);
    border:1px solid rgba(43,255,136,.35);
    border-radius:8px; color:var(--accent2);
    text-shadow:0 0 8px rgba(43,255,136,.35);
    user-select:none; pointer-events:none;
  }
  .livesHud{
    position:absolute; right:8px; top:8px;
    display:flex; gap:6px; align-items:center;
    background:rgba(0,0,0,.35);
    border:1px solid rgba(43,255,136,.25);
    border-radius:8px; padding:4px 6px;
    user-select:none; pointer-events:none;
  }
  .livesHud img{ width:18px; height:18px; image-rendering:auto; }

  .chargeLabel{
    position:absolute; left:50%; transform:translateX(-50%);
    top:28px; color:var(--muted); font-size:12px; user-select:none;
  }
  .chargeHud{
    position:absolute; left:50%; transform:translateX(-50%);
    top:44px; width:180px; height:10px;
    background:rgba(255,255,255,.08); border:1px solid rgba(43,255,136,.35); border-radius:999px;
    overflow:hidden; user-select:none;
  }
  .chargeFill{height:100%; width:0%; background:linear-gradient(90deg, #2bff88, #6bffda)}

  /* Overlay fine partita */
  .overlayMsg{
    position:absolute; inset:0;
    display:none; align-items:center; justify-content:center;
    background:rgba(0,0,0,.45);
    pointer-events:none;
  }
  .overlayMsg .box{
    padding:14px 18px; border-radius:12px; background:rgba(0,0,0,.75);
    border:1px solid rgba(43,255,136,.35); color:#fff; font-weight:700;
    text-shadow:0 0 10px rgba(43,255,136,.35);
    font-size:clamp(16px,2.2vw,22px); max-width:80%; text-align:center;
  }

  .blink{ animation: bl 0.12s linear infinite alternate; }
  @keyframes bl { from{opacity:1} to{opacity:.35} }
</style>
</head>
<body><h1>diominchia</h1>
  <main class="page">
    <!-- HERO -->
    <div class="hero" id="heroBox"></div>

    <h1>Combinazione di Simboli</h1>
    <p class="sub">Allinea i quattro simboli corretti per risvegliare l'oscuro portale.</p>

    <section class="panel" id="panel"></section>

    <div class="action">
      <button id="shuffle">Mescola</button>
      <button id="check">Verifica</button>
    </div>
    <div id="message" class="msg"></div>
    <div class="footer" id="hintBox"></div>

    <!-- RITUALE -->
    <section id="rituale">
      <p class="rituale-text" id="ritText"></p>
      <div class="rit-title">Inizia il Rituale</div>

      <div class="ritual-wrap">
        <img class="rit-gif" src="https://media1.giphy.com/media/v1.Y2lkPTc5MGI3NjExeHlhOXY3M3hsb3cxdnlkbDRsM3M3c2tpNHA2ejFoaHFudzE4ZDlwZyZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/9zOiTQ7RPxU7C/giphy.gif" alt="fuoco sinistro">
        <div class="pentacolo">
          <svg viewBox="0 0 100 100" width="100%" height="100%" aria-hidden="true" style="position:absolute;left:0;top:0;filter:drop-shadow(0 0 10px rgba(43,255,136,.35));">
            <circle cx="50" cy="50" r="45" fill="none" stroke="rgba(43,255,136,.35)" stroke-width="2"/>
            <polygon points="50,6 61,40 96,40 67,60 78,94 50,73 22,94 33,60 4,40 39,40" fill="none" stroke="rgba(43,255,136,.55)" stroke-width="2"/>
          </svg>
          <div class="rit-field rf-top"><input id="f1" type="text" placeholder="Ingrediente (sopra)"></div>
          <div class="rit-field rf-mid"><input id="f2" type="text" placeholder="Ingrediente (centro)"></div>
          <div class="rit-field rf-bottom"><input id="f3" type="text" placeholder="Ingrediente (sotto)"></div>
          <button class="rit-btn" id="completeBtn">Completa</button>
        </div>
        <img class="rit-gif" src="https://media1.giphy.com/media/v1.Y2lkPTc5MGI3NjExeHlhOXY3M3hsb3cxdnlkbDRsM3M3c2tpNHA2ejFoaHFudzE4ZDlwZyZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/9zOiTQ7RPxU7C/giphy.gif" alt="fuoco destro">
      </div>

      <div id="ritMsg" class="rit-msg"></div>
    </section>

    <!-- GIOCO -->
    <section id="game">
      <h2>La Corsa della Zucca</h2>
      <div id="goal">Obiettivo: raggiungi un punteggio di <strong>666</strong> per superare il livello.</div>
      <div id="canvasWrap">
        <div id="scoreHud" class="scoreHud">0</div>
        <div class="chargeLabel">Carica volo</div>
        <div id="chargeHud" class="chargeHud"><div id="chargeFill" class="chargeFill"></div></div>
        <div id="livesHud" class="livesHud"></div>
        <div id="overlayMsg" class="overlayMsg"><div class="box" id="overlayBox"></div></div>
        <canvas id="runner" width="900" height="300"></canvas>
      </div>
      <div class="hud">Controlli: <strong>←</strong>/<strong>→</strong> muovi, <strong>SPAZIO</strong> o <strong>↑</strong> salta (tieni premuto <strong>↑</strong> per volo). Punteggio: <span class="score" id="score">0</span></div>
      <div class="loading" id="loadingMsg">Caricamento immagini…</div>
      <div class="cta" style="margin-top:10px"><button id="startGame">Avvia</button> <button id="restartGame" style="display:none">Riprova</button></div>
    </section>
  </main>

<script>
document.addEventListener('DOMContentLoaded', () => {
  /* HERO con fallback */
  const hero = document.getElementById('heroBox');
  const b = new Image(); b.src='media/home.png?v=1'; b.alt='Il Rituale';
  b.onload=()=>hero.appendChild(b);
  b.onerror=()=>{const fb=document.createElement('div');fb.className='hero-fallback';fb.textContent='MANCANTE: media/home.png';hero.appendChild(fb);};

  /* SIMBOLI */
  const SYMBOLS = Array.from({length:12},(_,i)=>({id:String(i+1),src:`./media/${i+1}.png?v=1`}));
  const TARGET = atob("MSwyLDMsNA==").split(","); // "1,2,3,4"

  const HINTS=[
    "Spesso gli oggetti dei rituali si nascondono nelle stanze più buie.",
    "Le scope delle streghe nascondono sempre qualcosa.",
    "Una volta ho sentito la storia di una \"casa del dolore\", forse si parlava di qualcosa di interessante?"
  ];
  document.getElementById('hintBox').textContent="Suggerimento: "+HINTS[Math.floor(Math.random()*HINTS.length)];

  const panel=document.getElementById('panel'), message=document.getElementById('message'),
        rituale=document.getElementById('rituale'), ritText=document.getElementById('ritText'),
        gameSec=document.getElementById('game');

  let state=[], ritualeShown=false;

  function renderSymbol(el,idx){
    el.innerHTML=''; const img=new Image(); img.src=SYMBOLS[idx].src; img.alt=`simbolo ${idx+1}`;
    img.onerror=()=>{el.innerHTML=`<div class="fallback">MANCANTE: ${SYMBOLS[idx].src}</div>`}; el.appendChild(img);
  }
  function createSlot(i){
    const wrap=document.createElement('div'); wrap.className='slot';
    const L=document.createElement('div'); L.className='arrow'; L.textContent='◀';
    const S=document.createElement('div'); S.className='symbol';
    const R=document.createElement('div'); R.className='arrow'; R.textContent='▶';
    wrap.append(L,S,R);
    state[i]=Math.floor(Math.random()*SYMBOLS.length); renderSymbol(S,state[i]);
    L.addEventListener('click',()=>{state[i]=(state[i]-1+SYMBOLS.length)%SYMBOLS.length;renderSymbol(S,state[i]);message.textContent='';});
    R.addEventListener('click',()=>{state[i]=(state[i]+1)%SYMBOLS.length;renderSymbol(S,state[i]);message.textContent='';});
    return wrap;
  }
  function build(){panel.innerHTML='';state=[];for(let i=0;i<4;i++)panel.appendChild(createSlot(i));}
  function shuffle(){for(let i=0;i<4;i++)state[i]=Math.floor(Math.random()*SYMBOLS.length);
    [...panel.children].forEach((slotEl,i)=>renderSymbol(slotEl.querySelector('.symbol'),state[i]));message.textContent='';}
  function check(){
    const picked=state.map(idx=>SYMBOLS[idx].id);
    const ok=picked.length===TARGET.length && picked.every((id,i)=>id===TARGET[i]);
    if(ok){
      message.className='msg success'; message.textContent='';
      if(!ritualeShown){
        ritText.textContent="Bene, molto bene. Quindi Herr Knock ti ha insegnato molto. Per procedere con il rituale è fondamentale trovare i tre ingredienti per Evocare il Principe delle Tenebre. Credo che tu possa trovarli all'interno del server, ma non sarà facile.";
        rituale.style.display='block'; rituale.scrollIntoView({behavior:'smooth'}); ritualeShown=true;
      }
    } else { message.className='msg fail'; message.textContent='sbagliato'; }
  }
  document.getElementById('shuffle').onclick=shuffle;
  document.getElementById('check').onclick=check;
  build();

  /* ===== RITUALE — ordine libero ===== */
  const norm=(s)=>s.normalize('NFD').replace(/\p{Diacritic}/gu,'').toLowerCase().replace(/[^\p{L}\p{N}\s]/gu,'').replace(/\s+/g,' ').trim();
  function classify(text){
    const v=norm(text); if(!v) return null;
    const has=(...ws)=>ws.every(w=>v.includes(w));
    if(v.includes('candela') && (v.includes('nera')||v.includes('nero'))) return 'CANDLE';
    const rust=v.includes('arrugginito')||v.includes('arrugginita')||v.includes('ossidato')||v.includes('ossidata')||v.includes('ruggine');
    if(v.includes('coltello') && rust && has('simbolo','bestia')) return 'KNIFE';
    const peli=v.includes('peli')||v.includes('pelo'); const pub=v.includes('pubici')||v.includes('pubico');
    const fem=v.includes('femmina')||v.includes('donna');
    if(peli && pub && v.includes('zombie') && fem) return 'HAIR';
    return null;
  }
  function submitRitual(){
    const types=[classify(f1.value), classify(f2.value), classify(f3.value)];
    const set=new Set(types.filter(Boolean));
    const ok=set.has('CANDLE') && set.has('KNIFE') && set.has('HAIR') && types.every(t=>t!==null);
    const box=document.getElementById('ritMsg');
    if(ok){
      box.className='rit-msg success';
      box.textContent='Il cerchio si illumina… il portale si apre!';
      gameSec.style.display='block'; gameSec.scrollIntoView({behavior:'smooth'});
    }else{
      box.className='rit-msg fail';
      box.textContent='La formula non risponde. Forse hai sbagliato gli ingredienti...';
    }
  }
  const f1=document.getElementById('f1'), f2=document.getElementById('f2'), f3=document.getElementById('f3');
  document.getElementById('completeBtn').onclick=submitRitual;
  ;[f1,f2,f3].forEach(el=>el.addEventListener('keydown',e=>{ if(e.key==='Enter') submitRitual(); e.stopPropagation(); }));

  /* =========================
     MINIGIOCO — Pumpkin Runner (volo fix + spawn random sfalsati + overlay)
     ========================= */
  const TARGET_SCORE = 666;

  // Canvas & UI
  const cvs = document.getElementById('runner'), ctx = cvs.getContext('2d');
  const scoreHudEl = document.getElementById('scoreHud');
  const scoreEl = document.getElementById('score');
  const livesHud = document.getElementById('livesHud');
  const chargeFill = document.getElementById('chargeFill');
  const overlay = document.getElementById('overlayMsg'), overlayBox=document.getElementById('overlayBox');
  const startBtn = document.getElementById('startGame'),
        restartBtn = document.getElementById('restartGame'),
        loadingMsg = document.getElementById('loadingMsg');

  // Immagini
  const playerImg = new Image(); playerImg.src = 'media/zucca.png?v=1';
  const heartImgSrc = 'media/heart.png';
  const bgImg = new Image(); bgImg.src = 'media/sfondo.png';
  const monsterNames = ['mostro1.png','mostro2.png','mostro3.png','mostro4.png'];
  const monsterImgs = monsterNames.map(n => { const im=new Image(); im.src='media/'+n+'?v=1'; return im; });

  function preload(imgs){
    const toLoad = imgs.filter(img => !img.complete || img.naturalWidth===0);
    if(toLoad.length===0) return Promise.resolve();
    return Promise.allSettled(toLoad.map(img => new Promise(res=>{
      img.addEventListener('load', res, {once:true});
      img.addEventListener('error', res, {once:true});
    })));
  }

  // Stato di gioco
  let running=false, gameOver=false, score=0, lastSpawn=0, lastTs=null;

  // Velocità mondo (già approvata)
  let speed = 0.8;
  const MAX_SPEED = 4.2;
  const ACCEL_PER_SEC = 0.04;
  const ACCEL_RAMP_TIME = 90;
  let elapsedRunTime = 0;

  // Sfondo parallax
  let bgOffset = 0;
  const BG_PARALLAX = 0.42;

  const ground = cvs.height - 40;
  const airLaneY = ground - 150;

  // Player con movimento orizzontale
  const player = { x:120, y:0, w:44, h:44, vx:0, vy:0, onGround:true };
  player.y = ground - player.h;

  // Oggetti
  const obstacles=[];   // {x,y,w,h,img,type:'ground'|'air'}
  const pickups=[];     // {x,y,type:'candle'|'heart', w,h, emoji}
  const spawnQueue=[];  // {type, delay}

  // Vite
  const MAX_LIVES = 3;
  let lives = MAX_LIVES;
  let invuln = 0;

  function renderLives(){
    livesHud.innerHTML='';
    for(let i=0;i<MAX_LIVES;i++){
      const im = document.createElement('img');
      im.src = heartImgSrc;
      if(i >= lives){ im.style.filter='grayscale(1) brightness(0.7)'; im.style.opacity='0.5'; }
      livesHud.appendChild(im);
    }
  }

  // Fisica salto + movimento + volo
  const GRAVITY = 0.52;            // per-frame
  const BASE_JUMP_VY = -11.0;
  const SHORT_CUT_VY = -3.0;
  const COYOTE_TIME = 0.14;
  const JUMP_BUFFER = 0.16;

  const MOVE_ACCEL = 0.20;
  const MOVE_ACCEL_AIR = 0.12;
  const MAX_VX = 3.0;
  const FRICTION = 0.86;

  // Volo (tenendo ↑)
  let upHeld = false;
  const MAX_FLIGHT_ENERGY = 0.5;   // metà carica massima
  let flightEnergy = MAX_FLIGHT_ENERGY;
  const FLIGHT_DRAIN = 0.6;        // /s mentre voli
  const FLIGHT_RECHARGE = 0.18;    // /s ricarica lenta
  const FLIGHT_BOOST = 0.70;       // spinta per-frame (compensa gravità 0.52)
  const FLIGHT_CLIMB_CAP = -4.2;   // velocità massima di salita (più negativo = più su)
  function updateChargeBar(){
    const pct = Math.round((flightEnergy / MAX_FLIGHT_ENERGY)*100);
    chargeFill.style.width = Math.max(0, Math.min(100, pct)) + '%';
  }

  let coyoteTimer = 0;
  let jumpBufferTimer = 0;
  let jumpHeld = false;
  let leftHeld = false;
  let rightHeld = false;

  function requestJump(){ jumpBufferTimer = JUMP_BUFFER; }

  function doDirectionalJump(){
    let vy = BASE_JUMP_VY;
    let impulseX = 0;
    if(rightHeld && !leftHeld){
      vy = BASE_JUMP_VY * 1.05;  // più alto e lungo in avanti
      impulseX = 2.8;
    } else if(leftHeld && !rightHeld){
      vy = BASE_JUMP_VY * 0.62;  // saltello corto all'indietro
      impulseX = -2.1;
    }
    player.vy = vy;
    player.vx += impulseX;
    player.vx = Math.max(-MAX_VX, Math.min(MAX_VX, player.vx));
    player.onGround = false;
    coyoteTimer = 0;
    jumpBufferTimer = 0;
  }

  function tryPerformJump(){
    if ((coyoteTimer > 0 || player.onGround) && jumpBufferTimer > 0){
      doDirectionalJump();
    }
  }

  // Spawner
  function spawnObstacleOfType(type){
    const img = monsterImgs[Math.floor(Math.random()*monsterImgs.length)];
    const w = 46 + Math.random()*10;
    const ratio = (img && img.naturalWidth) ? (img.naturalHeight/img.naturalWidth) : 1.2;
    const h = w * ratio;
    const y = (type==='ground') ? (ground-h) : (airLaneY - h/2);
    obstacles.push({ x:cvs.width+10, y, w, h, img, type });
  }

  function shuffleArray(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }

  function queuePattern(currentScore){
    // Quanti?
    let counts = { air:0, ground:0 };
    if(currentScore > 600){ counts = {air:2, ground:2}; }
    else if(currentScore > 400){ counts = {air:2, ground:1}; }
    else if(currentScore > 200){ counts = {air:1, ground:1}; }
    else { counts = {air: (Math.random()<0.5?1:0), ground: (Math.random()<0.5?1:0)}; if(counts.air===0 && counts.ground===0) counts.ground=1; }

    // Crea lista tipi e randomizza ordine
    const types = [];
    for(let i=0;i<counts.air;i++) types.push('air');
    for(let i=0;i<counts.ground;i++) types.push('ground');
    shuffleArray(types);

    // Ritardi sfalsati casuali
    const BASE_GAP = 0.18;
    const JITTER = 0.10; // ±100ms
    const startOffset = Math.random()*0.20; // 0–200ms prima del primo spawn
    types.forEach((t, idx)=>{
      const delay = startOffset + idx*BASE_GAP + (Math.random()*2*JITTER - JITTER);
      spawnQueue.push({type:t, delay: Math.max(0, delay)});
    });
  }

  // Collezionabili
  const PICKUP_CHANCE = 0.20;
  const PICKUP_COOLDOWN = 4.0;
  let lastPickupTime = -Infinity;

  function spawnPickup(){
    const now = performance.now() / 1000;
    if(now - lastPickupTime < PICKUP_COOLDOWN) return false;

    const type = Math.random() < 0.5 ? 'candle' : 'heart';
    const lane = Math.random() < 0.5 ? 'air' : 'ground';
    const emoji = type === 'candle' ? '🕯️' : '❤️';
    const fontSize = 24;
    const w = fontSize, h = fontSize;
    const y = lane === 'ground' ? (ground - h - 6) : (airLaneY - h/2);

    pickups.push({ x:cvs.width+10, y, w, h, emoji, type });
    lastPickupTime = now;
    return true;
  }

  function drawPickup(p){
    ctx.font = "24px system-ui, Apple Color Emoji, Segoe UI Emoji, Noto Color Emoji";
    ctx.textBaseline = "top";
    ctx.fillText(p.emoji, p.x, p.y);
  }

  function drawImage(img, x,y,w,h){ if(img && img.complete && img.naturalWidth) ctx.drawImage(img,x,y,w,h); }

  // Background
  function drawBackground(){
    if(bgImg && bgImg.complete && bgImg.naturalWidth){
      const bw = bgImg.naturalWidth;
      const bh = bgImg.naturalHeight;
      const scale = cvs.height / bh;
      const drawW = bw * scale;
      bgOffset = (bgOffset - (speed * BG_PARALLAX)) % drawW;
      if(bgOffset < -drawW) bgOffset += drawW;
      for(let x=bgOffset; x < cvs.width + drawW; x += drawW){
        ctx.drawImage(bgImg, 0, 0, bw, bh, Math.floor(x), 0, Math.ceil(drawW), cvs.height);
      }
    } else {
      const g = ctx.createLinearGradient(0,0,0,cvs.height);
      g.addColorStop(0,'#020202'); g.addColorStop(1,'#0a0a0a');
      ctx.fillStyle=g; ctx.fillRect(0,0,cvs.width,cvs.height);
    }
  }

  function resetGame(){
    running=false; gameOver=false; score=0; lastTs=null; lastSpawn=0;
    overlay.style.display='none'; overlayBox.textContent='';
    obstacles.length=0; pickups.length=0; spawnQueue.length=0;

    speed=0.8; elapsedRunTime=0;
    flightEnergy = MAX_FLIGHT_ENERGY; updateChargeBar();

    player.x=120; player.y=ground-player.h; player.vx=0; player.vy=0; player.onGround=true;
    scoreHudEl.textContent='0'; scoreEl.textContent='0';
    coyoteTimer = 0; jumpBufferTimer = 0; jumpHeld = false; leftHeld=false; rightHeld=false; upHeld=false;
    invuln = 0; lives = MAX_LIVES; renderLives();
    cvs.classList.remove('blink');
    lastPickupTime = -Infinity;
  }

  function endGameSuccess(){
    gameOver = true; running = false;
    overlay.style.display='flex';
    overlayBox.style.color = 'var(--ok)';
    overlayBox.textContent = 'XXXX';
    restartBtn.style.display='inline-block';
    cvs.classList.remove('blink');
  }

  function endGameFailure(){
    gameOver = true; running = false;
    overlay.style.display='flex';
    overlayBox.style.color = 'var(--err)';
    overlayBox.textContent = 'Ritenta quante volte vuoi, tanto non ci riuscirai mai!';
    restartBtn.style.display='inline-block';
    cvs.classList.remove('blink');
  }

  function hitPlayer(){
    if(invuln > 0 || gameOver) return;
    lives -= 1; renderLives();
    invuln = 1.2;
    cvs.classList.add('blink');
    if(lives <= 0){ endGameFailure(); }
  }

  function loop(ts){
    if(!running) return;
    const delta = lastTs ? (ts-lastTs)/1000 : 0; lastTs = ts;
    elapsedRunTime += delta;

    // Velocità mondo
    const t = Math.min(1, elapsedRunTime / ACCEL_RAMP_TIME);
    const eased = t*t*(3 - 2*t);
    const targetSpeed = 0.8 + (MAX_SPEED - 0.8) * eased;
    speed += (targetSpeed - speed) * ACCEL_PER_SEC;

    // Punteggio
    score += (1.1 + (speed-0.8)*0.22) * delta;
    const shown = Math.floor(score);
    scoreHudEl.textContent = shown;
    scoreEl.textContent = shown;
    if(score >= TARGET_SCORE && !gameOver){ endGameSuccess(); }

    // Sfondo
    drawBackground();

    // piste
    ctx.strokeStyle='rgba(43,255,136,.3)';
    ctx.beginPath(); ctx.moveTo(0,ground+0.5); ctx.lineTo(cvs.width,ground+0.5); ctx.stroke();
    ctx.setLineDash([6,6]); ctx.beginPath(); ctx.moveTo(0,airLaneY+0.5); ctx.lineTo(cvs.width,airLaneY+0.5); ctx.stroke(); ctx.setLineDash([]);

    // spawn pattern/pickup
    const baseInterval = 2400 - speed*90;
    const jitter = 900 * Math.random();
    const interval = Math.max(1400, baseInterval + jitter);

    if(ts - lastSpawn > interval){
      lastSpawn = ts;

      if(score < TARGET_SCORE && Math.random() < PICKUP_CHANCE){
        if(!spawnPickup()){ queuePattern(score); }
      } else {
        queuePattern(score);
      }
    }

    // esegui coda spawn sfalsati
    for(let i=spawnQueue.length-1;i>=0;i--){
      spawnQueue[i].delay -= delta;
      if(spawnQueue[i].delay <= 0){
        spawnObstacleOfType(spawnQueue[i].type);
        spawnQueue.splice(i,1);
      }
    }

    // pickups
    for(let i=pickups.length-1;i>=0;i--){
      const p = pickups[i];
      p.x -= speed;
      drawPickup(p);
      if(p.x + p.w < 0){ pickups.splice(i,1); continue; }
      const padP = 8, padO = 4;
      const px=player.x+padP, py=player.y+padP, pw=player.w-2*padP, ph=player.h-2*padP;
      const ox=p.x+padO, oy=p.y+padO, ow=p.w-2*padO, oh=p.h-2*padO;
      if(px < ox + ow && px + pw > ox && py < oy + oh && py + ph > oy){
        if(p.type === 'candle'){ score += 50; }
        else if(p.type === 'heart'){ if(lives < MAX_LIVES){ lives += 1; renderLives(); } }
        pickups.splice(i,1);
      }
    }

    // ostacoli
    for(let i=obstacles.length-1;i>=0;i--){
      const o=obstacles[i];
      o.x -= speed;
      drawImage(o.img, o.x, o.y, o.w, o.h);
      if(o.x + o.w < 0) obstacles.splice(i,1);

      const padP = 10, padO = 12;
      const px=player.x+padP, py=player.y+padP, pw=player.w-2*padP, ph=player.h-2*padP;
      const ox=o.x+padO, oy=o.y+padO, ow=o.w-2*padO, oh=o.h-2*padO;
      if(px < ox + ow && px + pw > ox && py < oy + oh && py + ph > oy){ hitPlayer(); }
    }

    /* --- Fisica player --- */

    // input orizzontale
    const accel = player.onGround ? MOVE_ACCEL : MOVE_ACCEL_AIR;
    if(leftHeld && !rightHeld)  player.vx -= accel;
    else if(rightHeld && !leftHeld) player.vx += accel;
    else player.vx *= FRICTION;
    player.vx = Math.max(-MAX_VX, Math.min(MAX_VX, player.vx));

    player.x += player.vx;
    const minX = 20, maxX = cvs.width * 0.7;
    if(player.x < minX){ player.x = minX; player.vx = Math.max(0, player.vx); }
    if(player.x > maxX){ player.x = maxX; player.vx = Math.min(0, player.vx); }

    // gravità
    player.vy += GRAVITY;

    // volo (tenendo ↑)
    if(upHeld && !player.onGround && flightEnergy > 0){
      player.vy -= FLIGHT_BOOST;                         // contrasta la gravità per-frame
      if(player.vy < FLIGHT_CLIMB_CAP) player.vy = FLIGHT_CLIMB_CAP; // cap salita
      flightEnergy = Math.max(0, flightEnergy - FLIGHT_DRAIN * delta);
      updateChargeBar();
    } else {
      // ricarica lenta
      flightEnergy = Math.min(MAX_FLIGHT_ENERGY, flightEnergy + FLIGHT_RECHARGE * delta);
      updateChargeBar();
    }

    player.y += player.vy;

    // atterraggio
    if(player.y + player.h >= ground){
      player.y = ground - player.h;
      if(!player.onGround){
        player.onGround = true;
        coyoteTimer = 0;
        tryPerformJump();
      } else {
        player.onGround = true;
      }
      if(player.vy > 0) player.vy = 0;
    } else {
      if(player.onGround){
        player.onGround = false;
        coyoteTimer = COYOTE_TIME;
      } else {
        coyoteTimer -= (delta);
      }
    }

    // salto variabile
    if(!jumpHeld && player.vy < SHORT_CUT_VY){
      player.vy = SHORT_CUT_VY;
    }

    // timers
    jumpBufferTimer -= delta;
    invuln -= delta;
    if(invuln <= 0){ invuln = 0; cvs.classList.remove('blink'); }

    // draw player
    if(!(invuln>0 && Math.floor(ts/60)%2===0)){
      drawImage(playerImg, player.x, player.y, player.w, player.h);
    }

    requestAnimationFrame(loop);
  }

  // Input tastiera
  window.addEventListener('keydown', async (e)=>{
    const tag=document.activeElement && document.activeElement.tagName;
    if(tag==='INPUT' || tag==='TEXTAREA') return;

    if(e.code==='ArrowLeft'){ leftHeld = true; }
    if(e.code==='ArrowRight'){ rightHeld = true; }
    if(e.code==='ArrowUp'){ upHeld = true; }

    if(e.code==='Space' || e.code==='ArrowUp'){
      e.preventDefault();
      if(gameOver){ resetGame(); await startGame(); return; }
      jumpHeld = true;
      if(!running){ await startGame(); requestJump(); }
      else { requestJump(); tryPerformJump(); }
    }
  });
  window.addEventListener('keyup', (e)=>{
    if(e.code==='ArrowLeft'){ leftHeld = false; }
    if(e.code==='ArrowRight'){ rightHeld = false; }
    if(e.code==='ArrowUp'){ upHeld = false; jumpHeld = false; }
    if(e.code==='Space'){ jumpHeld = false; }
  });

  // Touch/click sul canvas
  document.getElementById('runner').addEventListener('pointerdown', ()=>{
    if(gameOver){ resetGame(); startGame(); return; }
    if(!running){ startGame(); requestJump(); }
    else { jumpHeld = true; upHeld = true; requestJump(); tryPerformJump(); }
  });
  document.getElementById('runner').addEventListener('pointerup', ()=>{ jumpHeld=false; upHeld=false; });

  async function startGame(){
    loadingMsg.style.display='block';
    await preload([playerImg, bgImg, ...monsterImgs]);
    loadingMsg.style.display='none';

    if(!running){
      running = true; restartBtn.style.display='none'; requestAnimationFrame(loop);
    }
  }

  document.getElementById('startGame').onclick = startGame;
  document.getElementById('restartGame').onclick = ()=>{ resetGame(); startGame(); };

  // ready
  renderLives(); updateChargeBar();
});
</script>
</body>
</html>
