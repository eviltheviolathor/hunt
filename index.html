<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Il Rituale ‚Äî Catena di Simboli</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@700&display=swap');

  :root{
    --bg:#050505; --fg:#e6e6e6; --muted:#9aa0a6;
    --accent:#2bff88; --accent2:#6bffda;
    --card:#0d0d0d; --ok:#22c55e; --err:#ff4d4d;
  }
  *{box-sizing:border-box}
  html,body{margin:0;background:radial-gradient(circle at 50% 15%, #111 0%, #000 80%);color:var(--fg);font-family:'Cinzel Decorative', serif; scroll-behavior:smooth}
  .page{max-width:1600px;margin:0 auto;padding:clamp(12px,2vw,24px);display:flex;flex-direction:column;align-items:center;text-align:center}

  /* HERO */
  .hero{width:100%;max-width:min(500px,50vw);margin:0 auto clamp(10px,2vw,18px)}
  .hero img{width:100%;height:auto;display:block;border-radius:10px}
  .hero-fallback{width:100%;padding:clamp(16px,2vw,28px);border:2px dashed rgba(43,255,136,.35);border-radius:10px;color:var(--accent2)}

  h1{font-size:clamp(24px,5vw,42px);margin:clamp(8px,1.5vw,12px) 0;color:var(--accent);text-shadow:0 0 12px var(--accent),0 0 28px var(--accent2);letter-spacing:.06em}
  .sub{color:var(--muted);margin:0 0 clamp(12px,2vw,18px);font-size:clamp(14px,2vw,18px)}

  /* COMBINAZIONE */
  .panel{display:grid;grid-template-columns:repeat(auto-fit,minmax(min(220px,42vw),1fr));gap:clamp(12px,2vw,20px);width:100%;max-width:min(1200px,96vw);padding:clamp(12px,2vw,16px);border-radius:16px;background:rgba(20,20,20,.85);box-shadow:0 0 40px rgba(43,255,136,.25),inset 0 0 20px rgba(43,255,136,.15)}
  .slot{background:radial-gradient(300px 300px at 50% 30%, rgba(43,255,136,.08), transparent 70%), var(--card);border:2px solid rgba(43,255,136,.3);border-radius:16px;padding:clamp(8px,1.8vw,12px);display:flex;align-items:center;justify-content:center;gap:clamp(8px,1.5vw,10px);min-height:clamp(200px,28vw,320px);box-shadow:inset 0 0 20px rgba(43,255,136,.15)}
  .symbol{flex:1;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.6);border:1px solid rgba(43,255,136,.4);box-shadow:0 0 20px rgba(43,255,136,.15),inset 0 0 15px rgba(43,255,136,.1);border-radius:12px;overflow:hidden}
  .symbol img{width:100%;height:100%;max-width:clamp(160px,22vw,280px);max-height:clamp(160px,22vw,280px);object-fit:contain}
  .fallback{color:var(--accent2);font-size:.92rem;padding:6px;text-align:center}
  .arrow{width:clamp(36px,4.5vw,44px);height:clamp(36px,4.5vw,44px);display:flex;align-items:center;justify-content:center;font-size:clamp(18px,2.5vw,20px);cursor:pointer;color:var(--fg);background:rgba(30,30,30,.8);border:1px solid rgba(43,255,136,.3);border-radius:8px}
  .arrow:hover{background:rgba(43,255,136,.15)}
  .action{margin:clamp(12px,2vw,16px) 0;display:flex;gap:clamp(8px,1.5vw,12px);justify-content:center}
  button{appearance:none;border:0;cursor:pointer;border-radius:8px;padding:10px 16px;font-weight:700;font-size:1rem;background:rgba(30,30,30,.9);color:var(--fg);border:2px solid rgba(43,255,136,.3);font-family:'Cinzel Decorative',serif}
  button:hover{background:rgba(43,255,136,.15)}
  .msg{min-height:28px;font-size:1.1rem;margin-top:6px}
  .success{color:var(--ok)} .fail{color:var(--err)}
  .footer{margin-top:clamp(12px,2vw,18px);color:var(--accent2);font-size:.95rem}

  /* RITUALE (NASCOSTO all'avvio) */
  #rituale{display:none;width:100%;max-width:min(1100px,96vw);margin:clamp(16px,2.5vw,24px) auto 0}
  .rituale-text{margin:12px auto 8px;line-height:1.45;color:var(--fg);font-size:clamp(14px,2vw,18px)}
  .rit-title{font-size:clamp(22px,4vw,36px);margin:8px 0 12px;color:var(--accent);text-shadow:0 0 10px var(--accent),0 0 24px var(--accent2);letter-spacing:.08em}
  .ritual-wrap{display:flex;align-items:center;justify-content:center;gap:16px;margin-top:8px}
  .rit-gif{width:140px;height:140px;object-fit:cover;border-radius:8px;box-shadow:0 0 16px rgba(43,255,136,.25)}
  @media (max-width:900px){.rit-gif{display:none}}
  .pentacolo{position:relative;width:min(90vw,600px);height:min(90vw,600px);margin:0 auto 24px}
  .pentacolo svg{transform:rotate(180deg)}
  .rit-field{position:absolute;transform:translate(-50%,-50%)}
  .rf-top    {left:50%; top:22%;  width:66%;}
  .rf-mid    {left:50%; top:50%;  width:60%;}
  .rf-bottom {left:50%; top:78%;  width:66%;}
  .rit-field input{width:100%;padding:10px 12px;border-radius:10px;border:2px solid rgba(43,255,136,.35);background:rgba(10,10,10,.85);color:var(--fg);font-size:clamp(14px,2vw,16px)}
  .rit-btn{position:absolute;left:50%;top:62%;transform:translate(-50%,-50%)}
  .rit-msg{min-height:20px;margin-top:8px;font-size:1rem}

  @media (max-width:700px){
    .rf-top   {left:50%; top:106%; width:92%;}
    .rf-mid   {left:50%; top:124%; width:92%;}
    .rf-bottom{left:50%; top:142%; width:92%;}
    .rit-btn  {top:160%;}
  }

  /* GIOCO (NASCOSTO all'avvio) */
  #game{display:none;width:100%;max-width:100vw;margin:28px auto 0;text-align:center}
  #game h2{margin:8px 0 6px;font-size:clamp(20px,4vw,28px);color:var(--accent);text-shadow:0 0 10px var(--accent)}
  #goal{color:var(--muted); margin-bottom:8px}
  #canvasWrap{
    width:100%;
    background:#000;border:2px solid rgba(43,255,136,.3);border-radius:10px;padding:8px;
    position:relative; transition:filter .2s ease;
    margin:0 auto; max-width:100vw;
  }
  #canvasWrap.invert{ filter: invert(1) hue-rotate(180deg); }
  canvas{display:block;width:100%;height:auto;background:#000}
  .hud{color:var(--muted);margin-top:8px;font-size:clamp(14px,2vw,16px)}
  .scoreHud{
    position:absolute; left:8px; top:8px;
    padding:6px 10px; font-weight:700;
    background:rgba(0,0,0,.55);
    border:1px solid rgba(43,255,136,.35);
    border-radius:8px; color:var(--accent2);
    user-select:none; pointer-events:none;
  }
  .livesHud{
    position:absolute; right:8px; top:8px;
    display:flex; gap:6px; align-items:center;
    background:rgba(0,0,0,.35);
    border:1px solid rgba(43,255,136,.25);
    border-radius:8px; padding:4px 6px;
    user-select:none; pointer-events:none;
  }
  .livesHud img{ width:18px; height:18px; }
  .chargeLabel{
    position:absolute; left:50%; transform:translateX(-50%);
    top:28px; color:var(--muted); font-size:12px; user-select:none;
  }
  .chargeHud{
    position:absolute; left:50%; transform:translateX(-50%);
    top:44px; width:220px; height:12px;
    background:rgba(255,255,255,.08); border:1px solid rgba(43,255,136,.35); border-radius:999px;
    overflow:hidden; user-select:none; }
  .chargeFill{height:100%; width:0%; background:linear-gradient(90deg, #2bff88, #6bffda)}
  .overlayMsg{
    position:absolute; inset:0; display:none; align-items:center; justify-content:center;
    background:rgba(0,0,0,.45); pointer-events:none; }
  .overlayMsg .box{
    padding:14px 18px; border-radius:12px; background:rgba(0,0,0,.75);
    border:1px solid rgba(43,255,136,.35); color:#fff; font-weight:700;
    font-size:clamp(16px,2.2vw,22px); max-width:80%; text-align:center; }

  /* SPECIFICHE */
  .specs{
    max-width:100%;
    margin:14px auto 0;
    text-align:left;
    background:rgba(0,0,0,.45);
    border:1px solid rgba(43,255,136,.25);
    border-radius:12px;
    padding:12px 14px;
    color:var(--fg);
  }
  .specs h4{margin:0 0 6px; color:var(--accent); font-size:clamp(16px,3vw,20px)}
  .specs ul{margin:8px 0 0 18px}
  .specs li{margin:4px 0}

  /* Epilogo (solo se sbloccato) */
  .lore{
    max-width:min(900px,96vw);
    margin:28px auto 0;
    text-align:center;
    background:rgba(0,0,0,.5);
    border:1px solid rgba(43,255,136,.25);
    border-radius:12px;
    padding:14px 16px;
    line-height:1.6;
    display:none;
  }
  .lore h3{ margin:0 0 8px; color:var(--accent); font-size:clamp(18px,3vw,22px); }
  .lore p{ margin:10px 0; color:var(--fg); }
  .lore .instr{ margin-top:12px; color:var(--accent2); border-top:1px dashed rgba(43,255,136,.25); padding-top:10px; font-weight:700; }
  .lore button{ margin-top:12px; padding:10px 14px; border-radius:10px; background:rgba(30,30,30,.9); color:#fff; border:2px solid rgba(43,255,136,.35); font-weight:800; cursor:pointer; }

  .blink{ animation: bl 0.12s linear infinite alternate; }
  @keyframes bl { from{opacity:1} to{opacity:.35} }
</style>
</head>
<body>
  <main class="page">
    <!-- HERO -->
    <div class="hero" id="heroBox"></div>

    <h1>Catena di Simboli</h1>
    <p class="sub">Allinea i quattro simboli corretti per risvegliare l'oscuro portale.</p>

    <section class="panel" id="panel"></section>

    <div class="action">
      <button id="shuffle">Mescola</button>
      <button id="check">Verifica</button>
    </div>
    <div id="message" class="msg"></div>
    <div class="footer" id="hintBox"></div>

    <!-- RITUALE (nascosto, si mostra dopo la combinazione corretta) -->
    <section id="rituale">
      <p class="rituale-text" id="ritText"></p>
      <div class="rit-title">Inizia il Rituale</div>

      <div class="ritual-wrap">
        <img class="rit-gif" src="https://media1.giphy.com/media/v1.Y2lkPTc5MGI3NjExeHlhOXY3M3hsb3cxdnlkbDRsM3M3c2tpNHA2ejFoaHFudzE4ZDlwZyZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/9zOiTQ7RPxU7C/giphy.gif" alt="fuoco sinistro">
        <div class="pentacolo">
          <svg viewBox="0 0 100 100" width="100%" height="100%" aria-hidden="true" style="position:absolute;left:0;top:0;filter:drop-shadow(0 0 10px rgba(43,255,136,.35));">
            <circle cx="50" cy="50" r="45" fill="none" stroke="rgba(43,255,136,.35)" stroke-width="2"/>
            <polygon points="50,6 61,40 96,40 67,60 78,94 50,73 22,94 33,60 4,40 39,40" fill="none" stroke="rgba(43,255,136,.55)" stroke-width="2"/>
          </svg>
          <div class="rit-field rf-top"><input id="f1" type="text" placeholder="Ingrediente (sopra)"></div>
          <div class="rit-field rf-mid"><input id="f2" type="text" placeholder="Ingrediente (centro)"></div>
          <div class="rit-field rf-bottom"><input id="f3" type="text" placeholder="Ingrediente (sotto)"></div>
          <button class="rit-btn" id="completeBtn">Completa</button>
        </div>
        <img class="rit-gif" src="https://media1.giphy.com/media/v1.Y2lkPTc5MGI3NjExeHlhOXY3M3hsb3cxdnlkbDRsM3M3c2tpNHA2ejFoaHFudzE4ZDlwZyZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/9zOiTQ7RPxU7C/giphy.gif" alt="fuoco destro">
      </div>

      <div id="ritMsg" class="rit-msg"></div>
    </section>

    <!-- GIOCO (nascosto fino al rituale) -->
    <section id="game">
      <h2>La Corsa della Zucca</h2>
      <div id="goal">Obiettivo (debug): <strong>10</strong> punti per sbloccare l‚Äôepilogo.</div>
      <div id="canvasWrap">
        <div id="scoreHud" class="scoreHud">0</div>
        <div class="chargeLabel">Carica volo</div>
        <div id="chargeHud" class="chargeHud"><div id="chargeFill" class="chargeFill"></div></div>
        <div id="livesHud" class="livesHud"></div>
        <div id="overlayMsg" class="overlayMsg"><div class="box" id="overlayBox"></div></div>
        <canvas id="runner" width="900" height="300"></canvas>
      </div>
      <div class="hud">Controlli: <strong>‚Üê</strong>/<strong>‚Üí</strong> muovi, <strong>SPAZIO</strong> o <strong>‚Üë</strong> salta (tieni <strong>‚Üë</strong> per volo). Punteggio: <span class="score" id="score">0</span></div>
      <div class="loading" id="loadingMsg">Caricamento immagini‚Ä¶</div>
      <div class="cta" style="margin-top:10px"><button id="startGame">Avvia</button> <button id="restartGame" style="display:none">Riprova</button></div>

      <!-- SPECIFICHE -->
      <div class="specs">
        <h4>Specifiche del livello</h4>
        <ul>
          <li>üïØÔ∏è <strong>Candela</strong>: +50 punti.</li>
          <li>‚ù§Ô∏è <strong>Cuore</strong>: recupera 1 vita (max 3).</li>
          <li>üêû <strong>Insetto</strong>: comandi invertiti per 5 secondi.</li>
          <li><strong>Volo</strong>: tieni premuto <strong>‚Üë</strong> in aria per rimanere sospeso; l‚Äôenergia scende e si ricarica lentamente a terra.</li>
          <li>Salto direzionale: <strong>‚Üí + salto</strong> = lungo & basso; <strong>‚Üê + salto</strong> = corto & all‚Äôindietro.</li>
        </ul>
      </div>
    </section>

    <!-- EPILOGO -->
    <section class="lore" id="epilogue">
      <h3>Il Sussurro del Pentacolo</h3>
      <p>Hai composto i simboli proibiti, tracciato il rituale e posizionato il pugnale. La candela nera illumina il centro del pentacolo e dopo aver bruciato i peli pubici della zombie rossa sei sopravvissuto agli incubi di guardia: una voce, profonda e demoniaca ti riconosce.</p>
      <p class="instr">Mostra a tutti la tua opera, ottieni il tuo ruolo, scrivi in Dark Room <strong>/rispondi</strong> e immetti il codice segreto: <strong>258069759</strong></p>
      <button id="obeyBtn">Ho Ubbidito, Signore delle Tenebre!</button>
      <div class="hidden-part" id="sacrificeBlock" style="display:none">
        <p><em>"Ogni rituale demoniaco, per essere portato a compimento ha bisogno di un sacrificio, chi sar√† la tua vittima sacrificale?"</em></p>
        <p class="instr">"A mezzanotte (e solo a mezzanotte) nella Dark Room usa il comando <strong>/Sacrifica</strong> e nomina l'utente. Attenzione per√≤, il malcapitato perder√† la met√† dei suoi punti esperienza!"</p>
      </div>
    </section>
  </main>

<script>
document.addEventListener('DOMContentLoaded', () => {
  /* ====== Parametri chiave ====== */
  const TARGET_SCORE = 10; // DEBUG ‚Äî rimetti 666 quando vuoi

  /* Helper autoscroll */
  function autoScrollTo(el){
    if(!el) return;
    // aspetta che il layout si aggiorni e poi scrolla
    setTimeout(()=>{ el.scrollIntoView({behavior:'smooth', block:'start'}); }, 60);
  }

  /* HERO con fallback */
  const hero = document.getElementById('heroBox');
  const b = new Image(); b.src='media/home.png?v=1'; b.alt='Il Rituale';
  b.onload=()=>hero.appendChild(b);
  b.onerror=()=>{const fb=document.createElement('div');fb.className='hero-fallback';fb.textContent='MANCANTE: media/home.png';hero.appendChild(fb);};

  /* SIMBOLI */
  const SYMBOLS = Array.from({length:12},(_,i)=>({id:String(i+1),src:`./media/${i+1}.png?v=1`}));
  const TARGET = atob("MSwyLDMsNA==").split(","); // "1,2,3,4"
  const HINTS=[
    "Spesso gli oggetti dei rituali si nascondono nelle stanze pi√π buie.",
    "Le scope delle streghe nascondono sempre qualcosa.",
    "Una volta ho sentito la storia di una \"casa del dolore\", forse si parlava di qualcosa di interessante?"
  ];
  document.getElementById('hintBox').textContent="Suggerimento: "+HINTS[Math.floor(Math.random()*HINTS.length)];

  const panel=document.getElementById('panel'), message=document.getElementById('message'),
        rituale=document.getElementById('rituale'), ritText=document.getElementById('ritText'),
        gameSec=document.getElementById('game'), epilogue=document.getElementById('epilogue');

  let state=[], ritualeShown=false;

  function renderSymbol(el,idx){
    el.innerHTML=''; const img=new Image(); img.src=SYMBOLS[idx].src; img.alt=`simbolo ${idx+1}`;
    img.onerror=()=>{el.innerHTML=`<div class="fallback">MANCANTE: ${SYMBOLS[idx].src}</div>`}; el.appendChild(img);
  }
  function createSlot(i){
    const wrap=document.createElement('div'); wrap.className='slot';
    const L=document.createElement('div'); L.className='arrow'; L.textContent='‚óÄ';
    const S=document.createElement('div'); S.className='symbol';
    const R=document.createElement('div'); R.className='arrow'; R.textContent='‚ñ∂';
    wrap.append(L,S,R);
    state[i]=Math.floor(Math.random()*SYMBOLS.length); renderSymbol(S,state[i]);
    L.addEventListener('click',()=>{state[i]=(state[i]-1+SYMBOLS.length)%SYMBOLS.length;renderSymbol(S,state[i]);message.textContent='';});
    R.addEventListener('click',()=>{state[i]=(state[i]+1)%SYMBOLS.length;renderSymbol(S,state[i]);message.textContent='';});
    return wrap;
  }
  function build(){panel.innerHTML='';state=[];for(let i=0;i<4;i++)panel.appendChild(createSlot(i));}
  function shuffle(){for(let i=0;i<4;i++)state[i]=Math.floor(Math.random()*SYMBOLS.length);
    [...panel.children].forEach((slotEl,i)=>renderSymbol(slotEl.querySelector('.symbol'),state[i]));message.textContent='';}

  function check(){
    const picked=state.map(idx=>SYMBOLS[idx].id);
    const ok=picked.length===TARGET.length && picked.every((id,i)=>id===TARGET[i]);
    if(ok){
      message.className='msg success'; message.textContent='';
      if(!ritualeShown){
        ritText.textContent="Bene, molto bene. Quindi Herr Knock ti ha insegnato molto. Per procedere con il rituale √® fondamentale trovare i tre ingredienti per Evocare il Principe delle Tenebre. Credo che tu possa trovarli all'interno del server, ma non sar√† facile. Si tratta di tre oggetti, l'ordine non √® importante (il Principe adora il caos) ma fai attenzione a nominarli in maniera corretta.";
        rituale.style.display='block';
        ritualeShown=true;
        autoScrollTo(rituale);
      }
    } else { message.className='msg fail'; message.textContent='sbagliato'; }
  }
  document.getElementById('shuffle').onclick=shuffle;
  document.getElementById('check').onclick=check;
  build();

  /* ===== RITUALE ‚Äî validazione ingredienti e sblocco gioco ===== */
  const f1=document.getElementById('f1'), f2=document.getElementById('f2'), f3=document.getElementById('f3');
  const ritMsg=document.getElementById('ritMsg');
  function norm(s){return s.normalize('NFD').replace(/\p{Diacritic}/gu,'').toLowerCase().replace(/[^\p{L}\p{N}\s]/gu,'').replace(/\s+/g,' ').trim();}
  function classify(text){
    const v=norm(text); if(!v) return null;
    const has=(...ws)=>ws.every(w=>v.includes(w));
    if(v.includes('candela') && (v.includes('nera')||v.includes('nero'))) return 'CANDLE';
    const rust=v.includes('arrugginito')||v.includes('arrugginita')||v.includes('ossidato')||v.includes('ossidata')||v.includes('ruggine');
    if(v.includes('coltello') && rust && has('simbolo','bestia')) return 'KNIFE';
    const peli=v.includes('peli')||v.includes('pelo'); const pub=v.includes('pubici')||v.includes('pubico');
    const fem=v.includes('femmina')||v.includes('donna');
    if(peli && pub && v.includes('zombie') && fem) return 'HAIR';
    return null;
  }
  function submitRitual(){
    const types=[classify(f1.value), classify(f2.value), classify(f3.value)];
    const set=new Set(types.filter(Boolean));
    const ok=set.has('CANDLE') && set.has('KNIFE') && set.has('HAIR') && types.every(t=>t!==null);
    if(ok){
      ritMsg.className='rit-msg success';
      ritMsg.innerHTML='<strong>Il cerchio si illumina‚Ä¶ il portale si apre!</strong><br>Dalle ombre convergono verso di te delle terrificanti creature, scappa da loro prima che ti rubino l\'anima e dimostra di essere degno!';
      gameSec.style.display='block';
      autoScrollTo(gameSec);
    }else{
      ritMsg.className='rit-msg fail';
      ritMsg.textContent='La formula non risponde. Forse hai sbagliato gli ingredienti...';
    }
  }
  document.getElementById('completeBtn').onclick=submitRitual;
  [f1,f2,f3].forEach(el=>el.addEventListener('keydown',e=>{ if(e.key==='Enter') submitRitual(); e.stopPropagation(); }));

  /* =========================
     MINIGIOCO ‚Äî Pumpkin Runner (Responsive)
     ========================= */
  const BASE_W = 900, BASE_H = 300; // dimensioni logiche

  // Canvas & UI
  const cvs = document.getElementById('runner'), ctx = cvs.getContext('2d');
  const scoreHudEl = document.getElementById('scoreHud');
  const scoreEl = document.getElementById('score');
  const livesHud = document.getElementById('livesHud');
  const chargeFill = document.getElementById('chargeFill');
  const overlay = document.getElementById('overlayMsg'), overlayBox=document.getElementById('overlayBox');
  const startBtn = document.getElementById('startGame'),
        restartBtn = document.getElementById('restartGame'),
        loadingMsg = document.getElementById('loadingMsg');
  const wrap = document.getElementById('canvasWrap');

  // Immagini
  const playerImg = new Image(); playerImg.src = 'media/zucca.png?v=1';
  const heartImgSrc = 'media/heart.png';
  const bgImg = new Image(); bgImg.src = 'media/sfondo.png';
  const monsterNames = ['mostro1.png','mostro2.png','mostro3.png','mostro4.png'];
  const monsterImgs = monsterNames.map(n => { const im=new Image(); im.src='media/'+n+'?v=1'; return im; });

  function preload(imgs){
    const toLoad = imgs.filter(img => !img.complete || img.naturalWidth===0);
    if(toLoad.length===0) return Promise.resolve();
    return Promise.allSettled(toLoad.map(img => new Promise(res=>{
      img.addEventListener('load', res, {once:true});
      img.addEventListener('error', res, {once:true});
    })));
  }

  /* ---------- Stato/Costanti ---------- */
  let SCALE = 1;
  let running=false, gameOver=false, score=0, lastSpawn=0, lastTs=null;
  let cleared=false;

  // Velocit√† progressiva
  let speed = 0.8;
  let MAX_SPEED_BASE = 4.2;
  const SPEED_MULT_BASE = 1.10;
  const EXTRA_AFTER_300 = 1.30;
  const ACCEL_PER_SEC = 0.04;
  const ACCEL_RAMP_TIME = 90;
  let elapsedRunTime = 0;

  // Lanes
  let ground = 0, airLaneY = 0, midLaneY = 0;

  // Player
  const player = { x:120, y:0, w:44, h:44, vx:0, vy:0, onGround:true };

  // Oggetti
  const obstacles=[];   // {x,y,w,h,img,type,scale,baseX,baseY,oscA,oscT,oscP}
  const pickups=[];     // {x,y,w,h,type,emoji}
  const spawnQueue=[];  // {type, delay, scale}

  // Vite
  const MAX_LIVES = 3; let lives = MAX_LIVES; let invuln = 0;

  // Fisica + volo
  let GRAVITY = 0.52;
  let BASE_JUMP_VY = -11.0;
  let SHORT_CUT_VY = -3.0;
  const COYOTE_TIME = 0.14;
  const JUMP_BUFFER = 0.16;
  let coyoteTimer = 0, jumpBufferTimer = 0;

  let MOVE_ACCEL = 0.20;
  let MOVE_ACCEL_AIR = 0.12;
  let MAX_VX = 3.0;
  const FRICTION = 0.86;

  let FLIGHT_BOOST = 0.70;
  let FLIGHT_CLIMB_CAP = -4.2;
  const MAX_FLIGHT_ENERGY = 0.5;
  let FLIGHT_DRAIN = 0.6;
  let FLIGHT_RECHARGE = 0.06;
  let flightEnergy = MAX_FLIGHT_ENERGY;
  let FLIGHT_MIN_Y = 0;

  function updateChargeBar(){
    chargeFill.style.width = Math.round((flightEnergy / MAX_FLIGHT_ENERGY)*100) + '%';
  }

  // Effetti
  let shakeTime = 0;
  let effectTimer = 0, nextEffectAt = 10;
  let invertFilterTime = 0;
  let controlsInvertUntil = 0;
  const controlsInverted = ()=> performance.now()/1000 < controlsInvertUntil;

  /* ---------- Responsive ---------- */
  function calcBestScale(){
    const vw = window.innerWidth;
    const vh = window.innerHeight;
    const targetW = Math.max(600, Math.floor(vw * 0.98));
    const maxH = Math.floor(vh * 0.6);
    let s = targetW / BASE_W;
    let h = BASE_H * s;
    if(h > maxH){ s = maxH / BASE_H; }
    s = Math.max(0.8, Math.min(s, 3.0));
    return s;
  }
  function applyScale(newScale, keepPositions=true){
    const ratio = newScale / SCALE;
    SCALE = newScale;

    cvs.width = Math.round(BASE_W * SCALE);
    cvs.height = Math.round(BASE_H * SCALE);

    ground = cvs.height - Math.round(40 * SCALE);
    airLaneY = ground - Math.round(150 * SCALE);
    midLaneY = Math.round((ground + airLaneY)/2);

    MAX_SPEED_BASE = 4.2 * SCALE;
    speed = keepPositions ? speed * ratio : (0.8 * SCALE);

    GRAVITY = 0.52 * SCALE;
    BASE_JUMP_VY = -11.0 * SCALE;
    SHORT_CUT_VY = -3.0 * SCALE;
    MOVE_ACCEL = 0.20 * SCALE;
    MOVE_ACCEL_AIR = 0.12 * SCALE;
    MAX_VX = 3.0 * SCALE;

    FLIGHT_BOOST = 0.70 * SCALE;
    FLIGHT_CLIMB_CAP = -4.2 * SCALE;
    FLIGHT_MIN_Y = (airLaneY - (10 * SCALE)) - (44 * SCALE);

    if(keepPositions){
      player.x *= ratio; player.y *= ratio; player.w *= ratio; player.h *= ratio;
      player.vx *= ratio; player.vy *= ratio;
      obstacles.forEach(o=>{ o.x*=ratio; o.y*=ratio; o.w*=ratio; o.h*=ratio; o.baseX*=ratio; o.baseY*=ratio; o.oscA*=ratio; });
      pickups.forEach(p=>{ p.x*=ratio; p.y*=ratio; p.w*=ratio; p.h*=ratio; });
    } else {
      player.x = 120 * SCALE; player.w = 44 * SCALE; player.h = 44 * SCALE;
      player.y = ground - player.h; player.vx = 0; player.vy = 0; player.onGround = true;
    }
  }
  window.addEventListener('resize', ()=>applyScale(calcBestScale(), true));

  /* ---------- Disturbi ---------- */
  function maybeScheduleEffect(dt){
    if(score < 500) return;
    effectTimer += dt;
    if(effectTimer >= nextEffectAt){
      effectTimer = 0;
      nextEffectAt = 8 + Math.random()*6; // media ~10s
      if(Math.random() < 0.5){ shakeTime = 1.6; }
      else { invertFilterTime = 2.4; wrap.classList.add('invert'); }
    }
  }

  /* ---------- Spawn ostacoli ---------- */
  function drawImage(img, x,y,w,h){ if(img && img.complete && img.naturalWidth) ctx.drawImage(img,x,y,w,h); }

  function spawnObstacleNow(type, scale=1){
    const img = monsterImgs[Math.floor(Math.random()*monsterImgs.length)];
    const baseW = (46 + Math.random()*10) * SCALE;
    const w = baseW * scale;
    const ratio = (img && img.naturalWidth) ? (img.naturalHeight/img.naturalWidth) : 1.2;
    const h = w * ratio;

    let y;
    if(type==='ground'){ y = ground - h + (Math.random()*6 - 3) * SCALE; }
    else if(type==='air'){ y = airLaneY - h/2 + (Math.random()*12 - 6) * SCALE; }
    else { y = midLaneY - h/2 + (Math.random()*10 - 5) * SCALE; }

    obstacles.push({
      x:cvs.width+10, y, w, h, img, type, scale,
      baseX:cvs.width+10, baseY:y,
      oscA: (type==='air' ? (2 + Math.random()*4) : (type==='ground' ? (1 + Math.random()*2) : (1.5 + Math.random()*2.5))) * SCALE,
      oscT: 1.2 + Math.random()*0.8,
      oscP: Math.random()*Math.PI*2
    });
  }

  function shuffleArray(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j]]; } return a; }

  function queuePattern(currentScore){
    let minC=2, maxC=2;
    if(currentScore > 600){ minC=4, maxC=4; }
    else if(currentScore > 400){ minC=3, maxC=3; }

    let weights = {ground:0.62, mid:0.23, air:0.15};
    if(currentScore > 400) weights = {ground:0.58, mid:0.27, air:0.15};
    if(currentScore > 600) weights = {ground:0.55, mid:0.30, air:0.15};

    const count = Math.floor(Math.random()*(maxC-minC+1))+minC;

    function pickLane(){
      const r = Math.random();
      if(r < weights.ground) return 'ground';
      if(r < weights.ground + weights.mid) return 'mid';
      return 'air';
    }
    let types=[];
    for(let i=0;i<count;i++) types.push(pickLane());
    if(!types.includes('ground')) types[0] = 'ground';
    shuffleArray(types);

    const BASE_GAP = (0.22 + Math.random()*0.1);
    const JITTER = 0.14;
    const startOffset = Math.random()*0.3;
    const scaleBase = 0.9 + Math.min(0.3, currentScore/1000);

    types.forEach((t, idx)=>{
      const delay = startOffset + idx*BASE_GAP + (Math.random()*2*JITTER - JITTER);
      const scale = Math.max(0.8, Math.min(1.25, scaleBase + (Math.random()*0.2 - 0.1)));
      spawnQueue.push({type:t, delay: Math.max(0, delay), scale});
    });
  }

  /* ---------- Collezionabili ---------- */
  const PICKUP_CHANCE = 0.20;
  const PICKUP_COOLDOWN = 4.0;
  let lastPickupTime = -Infinity;

  function spawnPickup(){
    const now = performance.now() / 1000;
    if(now - lastPickupTime < PICKUP_COOLDOWN) return false;
    const pool = (score >= 500) ? ['candle','heart','bug'] : ['candle','heart'];
    const type = pool[Math.floor(Math.random()*pool.length)];
    const laneR = Math.random();
    const lane = laneR < 0.5 ? 'ground' : (laneR < 0.8 ? 'mid' : 'air');
    const emoji = type === 'candle' ? 'üïØÔ∏è' : (type === 'heart' ? '‚ù§Ô∏è' : 'üêû');
    const fontSize = 24 * SCALE;
    const w = fontSize, h = fontSize;
    let y = ground - h - (6*SCALE);
    if(lane==='air') y = airLaneY - h/2;
    else if(lane==='mid') y = midLaneY - h/2;

    pickups.push({ x:cvs.width+10, y, w, h, emoji, type });
    lastPickupTime = now;
    return true;
  }

  function drawPickup(p){
    ctx.font = `${24*SCALE}px system-ui, Apple Color Emoji, Segoe UI Emoji, Noto Color Emoji`;
    ctx.textBaseline = "top";
    ctx.fillText(p.emoji, p.x, p.y);
  }

  /* ---------- Reset & End ---------- */
  function renderLives(){
    livesHud.innerHTML='';
    for(let i=0;i<MAX_LIVES;i++){
      const im = document.createElement('img');
      im.src = heartImgSrc;
      if(i >= lives){ im.style.filter='grayscale(1) brightness(0.7)'; im.style.opacity='0.5'; }
      livesHud.appendChild(im);
    }
  }

  function resetGame(){
    running=false; gameOver=false; score=0; lastTs=null; lastSpawn=0; cleared=false;
    overlay.style.display='none'; overlayBox.textContent='';
    obstacles.length=0; pickups.length=0; spawnQueue.length=0;

    elapsedRunTime=0; effectTimer=0; nextEffectAt=10;
    shakeTime=0; invertFilterTime=0; wrap.classList.remove('invert');
    controlsInvertUntil=0;

    flightEnergy = MAX_FLIGHT_ENERGY; updateChargeBar();

    applyScale(calcBestScale(), false);

    scoreHudEl.textContent='0'; scoreEl.textContent='0';
    invuln = 0; lives = MAX_LIVES; renderLives();
    cvs.classList.remove('blink');
  }

  function endGame(){
    gameOver = true; running = false;
    overlay.style.display='flex';
    const finalScore = Math.floor(score);
    if(cleared){
      overlayBox.style.color = 'var(--ok)';
      overlayBox.textContent = `Hai Ottenuto ${finalScore} Punti!`;
      document.getElementById('epilogue').style.display='block';
      autoScrollTo(document.getElementById('epilogue'));
    } else {
      overlayBox.style.color = 'var(--err)';
      overlayBox.textContent = 'Ritenta quante volte vuoi, tanto non ci riuscirai mai!';
    }
    document.getElementById('restartGame').style.display='inline-block';
    cvs.classList.remove('blink');
  }

  /* ---------- Danni ---------- */
  function hitPlayer(){
    if(invuln > 0 || gameOver) return;
    lives -= 1; renderLives();
    invuln = 1.2;
    cvs.classList.add('blink');
    if(lives <= 0){ endGame(); }
  }

  /* ---------- Loop ---------- */
  let timeSec = 0, bgOffset = 0;

  function drawBackground(){
    if(bgImg && bgImg.complete && bgImg.naturalWidth){
      const bw = bgImg.naturalWidth, bh = bgImg.naturalHeight;
      const scale = cvs.height / bh, drawW = bw * scale;
      bgOffset = (bgOffset - (speed * 0.42)) % drawW;
      if(bgOffset < -drawW) bgOffset += drawW;
      for(let x=bgOffset; x < cvs.width + drawW; x += drawW){
        ctx.drawImage(bgImg, 0, 0, bw, bh, Math.floor(x), 0, Math.ceil(drawW), cvs.height);
      }
    } else {
      const g = ctx.createLinearGradient(0,0,0,cvs.height);
      g.addColorStop(0,'#020202'); g.addColorStop(1,'#0a0a0a');
      ctx.fillStyle=g; ctx.fillRect(0,0,cvs.width,cvs.height);
    }
  }

  function loop(ts){
    if(!running) return;
    const delta = lastTs ? (ts-lastTs)/1000 : 0; lastTs = ts;
    timeSec += delta;
    elapsedRunTime += delta;

    // velocit√† con rampa
    const t = Math.min(1, elapsedRunTime / ACCEL_RAMP_TIME);
    const eased = t*t*(3 - 2*t);
    const baseTarget = (0.8 * SCALE) + ((4.2 * SCALE) - (0.8 * SCALE)) * eased;
    const mult = (score >= 300) ? (SPEED_MULT_BASE * EXTRA_AFTER_300) : SPEED_MULT_BASE;
    const targetSpeed = baseTarget * mult;
    speed += (targetSpeed - speed) * ACCEL_PER_SEC;

    // punteggio & clear
    score += (1.1 + ((speed - (0.8*SCALE))/SCALE)*0.22) * delta;
    const shown = Math.floor(score);
    scoreHudEl.textContent = shown;
    scoreEl.textContent = shown;
    if(!cleared && score >= TARGET_SCORE){ cleared = true; }

    // effetti
    maybeScheduleEffect(delta);
    if(invertFilterTime > 0){ invertFilterTime -= delta; if(invertFilterTime <= 0){ wrap.classList.remove('invert'); } }
    if(shakeTime > 0) shakeTime -= delta;

    ctx.save();
    if(shakeTime > 0){
      const s = 2.5 * SCALE;
      const ox = (Math.random()*2-1)*s;
      const oy = (Math.random()*2-1)*s;
      ctx.translate(ox, oy);
    }

    drawBackground();

    // linee corsie
    ctx.strokeStyle='rgba(43,255,136,.3)';
    ctx.beginPath(); ctx.moveTo(0,ground+0.5); ctx.lineTo(cvs.width,ground+0.5); ctx.stroke();
    ctx.setLineDash([6*SCALE,6*SCALE]);
    ctx.beginPath(); ctx.moveTo(0,midLaneY+0.5); ctx.lineTo(cvs.width,midLaneY+0.5); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0,airLaneY+0.5); ctx.lineTo(cvs.width,airLaneY+0.5); ctx.stroke();
    ctx.setLineDash([]);

    // spawn clock
    const baseInterval = 2400 - (speed/SCALE)*90;
    const jitter = 900 * Math.random();
    const interval = Math.max(1400, baseInterval + jitter);

    if(ts - lastSpawn > interval){
      lastSpawn = ts;
      if(!cleared && Math.random() < PICKUP_CHANCE){
        if(!spawnPickup()){ queuePattern(score); }
      } else {
        queuePattern(score);
      }
    }

    // esegui coda sfalsata
    for(let i=spawnQueue.length-1;i>=0;i--){
      spawnQueue[i].delay -= delta;
      if(spawnQueue[i].delay <= 0){
        spawnObstacleNow(spawnQueue[i].type, spawnQueue[i].scale ?? 1);
        spawnQueue.splice(i,1);
      }
    }

    // pickups
    for(let i=pickups.length-1;i>=0;i--){
      const p = pickups[i];
      p.x -= speed;
      drawPickup(p);
      if(p.x + p.w < 0){ pickups.splice(i,1); continue; }
      const padP = 8*SCALE, padO = 4*SCALE;
      const px=player.x+padP, py=player.y+padP, pw=player.w-2*padP, ph=player.h-2*padP;
      const ox=p.x+padO, oy=p.y+padO, ow=p.w-2*padO, oh=p.h-2*padO;
      if(px < ox + ow && px + pw > ox && py < oy + oh && py + ph > oy){
        if(p.type === 'candle'){ score += 50; }
        else if(p.type === 'heart'){ if(lives < MAX_LIVES){ lives += 1; renderLives(); } }
        else if(p.type === 'bug'){ controlsInvertUntil = performance.now()/1000 + 5; }
        pickups.splice(i,1);
      }
    }

    // ostacoli (oscillazioni dopo 300)
    for(let i=obstacles.length-1;i>=0;i--){
      const o=obstacles[i];
      o.baseX -= speed;
      let drawX = o.baseX;
      let drawY = o.baseY;
      if(score >= 300){
        const phase = (timeSec + o.oscP) * (2*Math.PI / o.oscT);
        if(o.type === 'air')      drawY = o.baseY + Math.sin(phase) * o.oscA;
        else if(o.type === 'ground') drawX = o.baseX + Math.sin(phase) * (o.oscA*0.8);
        else                      drawY = o.baseY + Math.sin(phase) * (o.oscA*0.6);
      }
      o.x = drawX; o.y = drawY;

      drawImage(o.img, o.x, o.y, o.w, o.h);
      if(o.x + o.w < 0) obstacles.splice(i,1);

      const padP = 10*SCALE, padO = 12*SCALE;
      const px=player.x+padP, py=player.y+padP, pw=player.w-2*padP, ph=player.h-2*padP;
      const ox=o.x+padO, oy=o.y+padO, ow=o.w-2*padO, oh=o.h-2*padO;
      if(px < ox + ow && px + pw > ox && py < oy + oh && py + ph > oy){ hitPlayer(); }
    }

    /* --- Fisica player --- */
    const leftActive  = controlsInverted() ? keys.right : keys.left;
    const rightActive = controlsInverted() ? keys.left  : keys.right;

    const accel = player.onGround ? MOVE_ACCEL : MOVE_ACCEL_AIR;
    if(leftActive && !rightActive)  player.vx -= accel;
    else if(rightActive && !leftActive) player.vx += accel;
    else player.vx *= FRICTION;
    player.vx = Math.max(-MAX_VX, Math.min(MAX_VX, player.vx));

    player.x += player.vx;
    const minX = 20*SCALE, maxX = cvs.width * 0.7;
    if(player.x < minX){ player.x = minX; player.vx = Math.max(0, player.vx); }
    if(player.x > maxX){ player.x = maxX; player.vx = Math.min(0, player.vx); }

    // gravit√†
    player.vy += GRAVITY;

    // volo
    if(keys.up && !player.onGround && flightEnergy > 0){
      player.vy -= FLIGHT_BOOST;
      if(player.vy < FLIGHT_CLIMB_CAP) player.vy = FLIGHT_CLIMB_CAP;
      flightEnergy = Math.max(0, flightEnergy - FLIGHT_DRAIN * delta);
      updateChargeBar();
    } else {
      flightEnergy = Math.min(MAX_FLIGHT_ENERGY, flightEnergy + FLIGHT_RECHARGE * delta);
      updateChargeBar();
    }

    player.y += player.vy;

    // limiti verticali (massimo fino poco sopra la corsia alta)
    const topLimit = Math.min(FLIGHT_MIN_Y, 2);
    if(player.y < topLimit){
      player.y = topLimit;
      if(player.vy < 0) player.vy = 0;
    }

    // atterraggio & coyote
    if(player.y + player.h >= ground){
      player.y = ground - player.h;
      if(!player.onGround){ player.onGround = true; coyoteTimer = 0; tryPerformJump(); }
      if(player.vy > 0) player.vy = 0;
    } else {
      if(player.onGround){ player.onGround = false; coyoteTimer = COYOTE_TIME; }
      else { coyoteTimer -= delta; }
    }

    // salto variabile
    if(!keys.jumpHeld && player.vy < SHORT_CUT_VY){ player.vy = SHORT_CUT_VY; }

    // timers
    jumpBufferTimer -= delta;
    invuln -= delta;
    if(invuln <= 0){ invuln = 0; cvs.classList.remove('blink'); }

    // draw player
    if(!(invuln>0 && Math.floor(ts/60)%2===0)){
      drawImage(playerImg, player.x, player.y, player.w, player.h);
    }

    ctx.restore();
    requestAnimationFrame(loop);
  }

  /* ---------- Input ---------- */
  const keys = { left:false, right:false, up:false, jumpHeld:false };
  function requestJump(){ jumpBufferTimer = JUMP_BUFFER; }
  function doDirectionalJump(){
    let vy = BASE_JUMP_VY;
    let impulseX = 0;
    const leftActive  = controlsInverted() ? keys.right : keys.left;
    const rightActive = controlsInverted() ? keys.left  : keys.right;

    if(rightActive && !leftActive){ vy = BASE_JUMP_VY * 1.05; impulseX = 2.8 * SCALE; }
    else if(leftActive && !rightActive){ vy = BASE_JUMP_VY * 0.62; impulseX = -2.1 * SCALE; }

    player.vy = vy;
    player.vx = Math.max(-MAX_VX, Math.min(MAX_VX, player.vx + impulseX));
    player.onGround = false;
    coyoteTimer = 0; jumpBufferTimer = 0;
  }
  function tryPerformJump(){
    if ((coyoteTimer > 0 || player.onGround) && jumpBufferTimer > 0) doDirectionalJump();
  }

  window.addEventListener('keydown', async (e)=>{
    const tag=document.activeElement && document.activeElement.tagName;
    if(tag==='INPUT' || tag==='TEXTAREA') return;

    if(e.code==='ArrowLeft'){ keys.left = true; }
    if(e.code==='ArrowRight'){ keys.right = true; }
    if(e.code==='ArrowUp'){ keys.up = true; }

    if(e.code==='Space' || e.code==='ArrowUp'){
      e.preventDefault();
      if(gameOver){ resetGame(); await startGame(); return; }
      keys.jumpHeld = true;
      if(!running){ await startGame(); requestJump(); }
      else { requestJump(); tryPerformJump(); }
    }
  });
  window.addEventListener('keyup', (e)=>{
    if(e.code==='ArrowLeft'){ keys.left = false; }
    if(e.code==='ArrowRight'){ keys.right = false; }
    if(e.code==='ArrowUp'){ keys.up = false; keys.jumpHeld = false; }
    if(e.code==='Space'){ keys.jumpHeld = false; }
  });

  // Touch/click
  cvs.addEventListener('pointerdown', ()=>{
    if(gameOver){ resetGame(); startGame(); return; }
    if(!running){ startGame(); requestJump(); }
    else { keys.jumpHeld = true; keys.up = true; requestJump(); tryPerformJump(); }
  });
  cvs.addEventListener('pointerup', ()=>{ keys.jumpHeld=false; keys.up=false; });

  /* ---------- Avvio gioco ---------- */
  async function startGame(){
    loadingMsg.style.display='block';
    await preload([playerImg, bgImg, ...monsterImgs]);
    loadingMsg.style.display='none';
    if(!running){
      running = true; document.getElementById('restartGame').style.display='none'; requestAnimationFrame(loop);
    }
  }
  document.getElementById('startGame').onclick = startGame;
  document.getElementById('restartGame').onclick = ()=>{ resetGame(); startGame(); };

  /* Epilogo: mostra la parte del sacrificio al click (con autoscroll) */
  document.getElementById('obeyBtn').addEventListener('click', ()=>{
    const sb=document.getElementById('sacrificeBlock');
    if(sb){ sb.style.display='block'; autoScrollTo(sb); }
  });

  /* Inizializzazione */
  applyScale(calcBestScale(), false);
  renderLives(); updateChargeBar();
});
</script>
</body>
</html>
