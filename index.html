<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Il Rituale — Catena di Simboli</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@700&display=swap');

  :root{
    --bg:#050505; --fg:#e6e6e6; --muted:#9aa0a6;
    --accent:#2bff88; --accent2:#6bffda;
    --card:#0d0d0d; --ok:#22c55e; --err:#ff4d4d;
  }
  *{box-sizing:border-box}
  html,body{margin:0;background:radial-gradient(circle at 50% 15%, #111 0%, #000 80%);color:var(--fg);font-family:'Cinzel Decorative', serif; scroll-behavior:smooth}
  .page{max-width:1600px;margin:0 auto;padding:clamp(12px,2vw,24px);display:flex;flex-direction:column;align-items:center;text-align:center}

  /* HERO */
  .hero{width:100%;max-width:min(500px,50vw);margin:0 auto clamp(10px,2vw,18px)}
  .hero img{width:100%;height:auto;display:block;border-radius:10px}
  .hero-fallback{width:100%;padding:clamp(16px,2vw,28px);border:2px dashed rgba(43,255,136,.35);border-radius:10px;color:var(--accent2)}

  h1{font-size:clamp(24px,5vw,42px);margin:clamp(8px,1.5vw,12px) 0;color:var(--accent);text-shadow:0 0 12px var(--accent),0 0 28px var(--accent2);letter-spacing:.06em}
  .sub{color:var(--muted);margin:0 0 clamp(12px,2vw,18px);font-size:clamp(14px,2vw,18px)}

  /* COMBINAZIONE */
  .panel{display:grid;grid-template-columns:repeat(auto-fit,minmax(min(220px,42vw),1fr));gap:clamp(12px,2vw,20px);width:100%;max-width:min(1200px,96vw);padding:clamp(12px,2vw,16px);border-radius:16px;background:rgba(20,20,20,.85);box-shadow:0 0 40px rgba(43,255,136,.25),inset 0 0 20px rgba(43,255,136,.15)}
  .slot{background:radial-gradient(300px 300px at 50% 30%, rgba(43,255,136,.08), transparent 70%), var(--card);border:2px solid rgba(43,255,136,.3);border-radius:16px;padding:clamp(8px,1.8vw,12px);display:flex;align-items:center;justify-content:center;gap:clamp(8px,1.5vw,10px);min-height:clamp(200px,28vw,320px);box-shadow:inset 0 0 20px rgba(43,255,136,.15)}
  .symbol{flex:1;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.6);border:1px solid rgba(43,255,136,.4);box-shadow:0 0 20px rgba(43,255,136,.15),inset 0 0 15px rgba(43,255,136,.1);border-radius:12px;overflow:hidden}
  .symbol img{width:100%;height:100%;max-width:clamp(160px,22vw,280px);max-height:clamp(160px,22vw,280px);object-fit:contain}
  .fallback{color:var(--accent2);font-size:.92rem;padding:6px;text-align:center}
  .arrow{width:clamp(36px,4.5vw,44px);height:clamp(36px,4.5vw,44px);display:flex;align-items:center;justify-content:center;font-size:clamp(18px,2.5vw,20px);cursor:pointer;color:var(--fg);background:rgba(30,30,30,.8);border:1px solid rgba(43,255,136,.3);border-radius:8px}
  .arrow:hover{background:rgba(43,255,136,.15)}
  .action{margin:clamp(12px,2vw,16px) 0;display:flex;gap:clamp(8px,1.5vw,12px);justify-content:center}
  button{appearance:none;border:0;cursor:pointer;border-radius:8px;padding:10px 16px;font-weight:700;font-size:1rem;background:rgba(30,30,30,.9);color:var(--fg);border:2px solid rgba(43,255,136,.3);font-family:'Cinzel Decorative',serif}
  button:hover{background:rgba(43,255,136,.15)}
  .msg{min-height:28px;font-size:1.1rem;margin-top:6px}
  .success{color:var(--ok)} .fail{color:var(--err)}
  .footer{margin-top:clamp(12px,2vw,18px);color:var(--accent2);font-size:.95rem}

  /* RITUALE (NASCOSTO all'avvio) */
  #rituale{display:none;width:100%;max-width:min(1100px,96vw);margin:clamp(16px,2.5vw,24px) auto 0}
  .rituale-text{margin:12px auto 8px;line-height:1.45;color:var(--fg);font-size:clamp(14px,2vw,18px)}
  .rit-title{font-size:clamp(22px,4vw,36px);margin:8px 0 12px;color:var(--accent);text-shadow:0 0 10px var(--accent),0 0 24px var(--accent2);letter-spacing:.08em}
  .ritual-wrap{display:flex;align-items:center;justify-content:center;gap:16px;margin-top:8px}
  .rit-gif{width:140px;height:140px;object-fit:cover;border-radius:8px;box-shadow:0 0 16px rgba(43,255,136,.25)}
  @media (max-width:900px){.rit-gif{display:none}}
  .pentacolo{position:relative;width:min(90vw,600px);height:min(90vw,600px);margin:0 auto 24px}
  .pentacolo svg{transform:rotate(180deg)}
  .rit-field{position:absolute;transform:translate(-50%,-50%)}
  .rf-top    {left:50%; top:22%;  width:66%;}
  .rf-mid    {left:50%; top:50%;  width:60%;}
  .rf-bottom {left:50%; top:78%;  width:66%;}
  .rit-field input{width:100%;padding:10px 12px;border-radius:10px;border:2px solid rgba(43,255,136,.35);background:rgba(10,10,10,.85);color:var(--fg);font-size:clamp(14px,2vw,16px)}
  .rit-btn{position:absolute;left:50%;top:62%;transform:translate(-50%,-50%)}
  .rit-msg{min-height:20px;margin-top:8px;font-size:1rem}

  @media (max-width:700px){
    .rf-top   {left:50%; top:106%; width:92%;}
    .rf-mid   {left:50%; top:124%; width:92%;}
    .rf-bottom{left:50%; top:142%; width:92%;}
    .rit-btn  {top:160%;}
  }

  /* GIOCO (NASCOSTO all'avvio) */
  #game{display:none;width:100%;max-width:100vw;margin:28px auto 0;text-align:center}
  #game h2{margin:8px 0 6px;font-size:clamp(20px,4vw,28px);color:var(--accent);text-shadow:0 0 10px var(--accent)}
  #goal{color:var(--muted); margin-bottom:8px}
  #canvasWrap{
    width:100%;
    background:#000;border:2px solid rgba(43,255,136,.3);border-radius:10px;padding:8px;
    position:relative; transition:filter .2s ease;
    margin:0 auto; max-width:100vw;
  }
  #canvasWrap.invert{ filter: invert(1) hue-rotate(180deg); }
  canvas{display:block;width:100%;height:auto;background:#000}
  .hud{color:var(--muted);margin-top:8px;font-size:clamp(14px,2vw,16px)}
  .scoreHud{
    position:absolute; left:8px; top:8px;
    padding:6px 10px; font-weight:700;
    background:rgba(0,0,0,.55);
    border:1px solid rgba(43,255,136,.35);
    border-radius:8px; color:var(--accent2);
    user-select:none; pointer-events:none;
  }
  .livesHud{
    position:absolute; right:8px; top:8px;
    display:flex; gap:6px; align-items:center;
    background:rgba(0,0,0,.35);
    border:1px solid rgba(43,255,136,.25);
    border-radius:8px; padding:4px 6px;
    user-select:none; pointer-events:none;
  }
  .livesHud img{ width:18px; height:18px; }
  .chargeLabel{
    position:absolute; left:50%; transform:translateX(-50%);
    top:28px; color:var(--muted); font-size:12px; user-select:none;
  }
  .chargeHud{
    position:absolute; left:50%; transform:translateX(-50%);
    top:44px; width:220px; height:12px;
    background:rgba(255,255,255,.08); border:1px solid rgba(43,255,136,.35); border-radius:999px;
    overflow:hidden; user-select:none; }
  .chargeFill{height:100%; width:0%; background:linear-gradient(90deg, #2bff88, #6bffda)}
  .overlayMsg{
    position:absolute; inset:0; display:none; align-items:center; justify-content:center;
    background:rgba(0,0,0,.45); pointer-events:none; }
  .overlayMsg .box{
    padding:14px 18px; border-radius:12px; background:rgba(0,0,0,.75);
    border:1px solid rgba(43,255,136,.35); color:#fff; font-weight:700;
    font-size:clamp(16px,2.2vw,22px); max-width:80%; text-align:center; }

  /* SPECIFICHE */
  .specs{
    max-width:100%;
    margin:14px auto 0;
    text-align:left;
    background:rgba(0,0,0,.45);
    border:1px solid rgba(43,255,136,.25);
    border-radius:12px;
    padding:12px 14px;
    color:var(--fg);
  }
  .specs h4{margin:0 0 6px; color:var(--accent); font-size:clamp(16px,3vw,20px)}
  .specs ul{margin:8px 0 0 18px}
  .specs li{margin:4px 0}

  /* Epilogo (solo se sbloccato) */
  .lore{
    max-width:min(900px,96vw);
    margin:28px auto 0;
    text-align:center;
    background:rgba(0,0,0,.5);
    border:1px solid rgba(43,255,136,.25);
    border-radius:12px;
    padding:14px 16px;
    line-height:1.6;
    display:none;
  }
  .lore h3{ margin:0 0 8px; color:var(--accent); font-size:clamp(18px,3vw,22px); }
  .lore p{ margin:10px 0; color:var(--fg); }
  .lore .instr{ margin-top:12px; color:var(--accent2); border-top:1px dashed rgba(43,255,136,.25); padding-top:10px; font-weight:700; }
  .lore button{ margin-top:12px; padding:10px 14px; border-radius:10px; background:rgba(30,30,30,.9); color:#fff; border:2px solid rgba(43,255,136,.35); font-weight:800; cursor:pointer; }

  .blink{ animation: bl 0.12s linear infinite alternate; }
  @keyframes bl { from{opacity:1} to{opacity:.35} }
</style>
</head>
<body>
  <main class="page">
    <!-- HERO -->
    <div class="hero" id="heroBox"></div>

    <h1>Catena di Simboli</h1>
    <p class="sub">Allinea i quattro simboli corretti per risvegliare l'oscuro portale.</p>

    <section class="panel" id="panel"></section>

    <div class="action">
      <button id="shuffle">Mescola</button>
      <button id="check">Verifica</button>
    </div>
    <div id="message" class="msg"></div>
    <div class="footer" id="hintBox"></div>

    <!-- RITUALE (nascosto, si mostra dopo la combinazione corretta) -->
    <section id="rituale">
      <p class="rituale-text" id="ritText"></p>
      <div class="rit-title">Inizia il Rituale</div>

      <div class="ritual-wrap">
        <img class="rit-gif" src="https://media1.giphy.com/media/v1.Y2lkPTc5MGI3NjExeHlhOXY3M3hsb3cxdnlkbDRsM3M3c2tpNHA2ejFoaHFudzE4ZDlwZyZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/9zOiTQ7RPxU7C/giphy.gif" alt="fuoco sinistro">
        <div class="pentacolo">
          <svg viewBox="0 0 100 100" width="100%" height="100%" aria-hidden="true" style="position:absolute;left:0;top:0;filter:drop-shadow(0 0 10px rgba(43,255,136,.35));">
            <circle cx="50" cy="50" r="45" fill="none" stroke="rgba(43,255,136,.35)" stroke-width="2"/>
            <polygon points="50,6 61,40 96,40 67,60 78,94 50,73 22,94 33,60 4,40 39,40" fill="none" stroke="rgba(43,255,136,.55)" stroke-width="2"/>
          </svg>
          <div class="rit-field rf-top"><input id="f1" type="text" placeholder="Ingrediente (sopra)"></div>
          <div class="rit-field rf-mid"><input id="f2" type="text" placeholder="Ingrediente (centro)"></div>
          <div class="rit-field rf-bottom"><input id="f3" type="text" placeholder="Ingrediente (sotto)"></div>
          <button class="rit-btn" id="completeBtn">Completa</button>
        </div>
        <img class="rit-gif" src="https://media1.giphy.com/media/v1.Y2lkPTc5MGI3NjExeHlhOXY3M3hsb3cxdnlkbDRsM3M3c2tpNHA2ejFoaHFudzE4ZDlwZyZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/9zOiTQ7RPxU7C/giphy.gif" alt="fuoco destro">
      </div>

      <div id="ritMsg" class="rit-msg"></div>
    </section>

    <!-- GIOCO (nascosto fino al rituale) -->
    <section id="game">
      <h2>La Corsa della Zucca</h2>
      <div id="goal">Obiettivo (debug): <strong>10</strong> punti per sbloccare l’epilogo.</div>
      <div id="canvasWrap">
        <div id="scoreHud" class="scoreHud">0</div>
        <div class="chargeLabel">Carica volo</div>
        <div id="chargeHud" class="chargeHud"><div id="chargeFill" class="chargeFill"></div></div>
        <div id="livesHud" class="livesHud"></div>
        <div id="overlayMsg" class="overlayMsg"><div class="box" id="overlayBox"></div></div>
        <canvas id="runner" width="900" height="300"></canvas>
      </div>
      <div class="hud">Controlli: <strong>←</strong>/<strong>→</strong> muovi, <strong>SPAZIO</strong> o <strong>↑</strong> salta (tieni <strong>↑</strong> per volo). Punteggio: <span class="score" id="score">0</span></div>
      <div class="loading" id="loadingMsg">Caricamento immagini…</div>
      <div class="cta" style="margin-top:10px"><button id="startGame">Avvia</button> <button id="restartGame" style="display:none">Riprova</button></div>

      <!-- SPECIFICHE -->
      <div class="specs">
        <h4>Specifiche del livello</h4>
        <ul>
          <li>🕯️ <strong>Candela</strong>: +50 punti.</li>
          <li>❤️ <strong>Cuore</strong>: recupera 1 vita (max 3).</li>
          <li>🐞 <strong>Insetto</strong>: comandi invertiti per 5 secondi.</li>
          <li><strong>Volo</strong>: tieni premuto <strong>↑</strong> in aria per rimanere sospeso; l’energia scende e si ricarica lentamente a terra.</li>
          <li>Salto direzionale: <strong>→ + salto</strong> = lungo & basso; <strong>← + salto</strong> = corto & all’indietro.</li>
        </ul>
      </div>
    </section>

    <!-- EPILOGO -->
    <section class="lore" id="epilogue">
      <h3>Il Sussurro del Pentacolo</h3>
      <p>Hai composto i simboli proibiti, tracciato il rituale e posizionato il pugnale. La candela nera illumina il centro del pentacolo e dopo aver bruciato i peli pubici della zombie rossa sei sopravvissuto agli incubi di guardia: una voce, profonda e demoniaca ti riconosce.</p>
      <p class="instr">Mostra a tutti la tua opera, ottieni il tuo ruolo, scrivi in Dark Room <strong>/rispondi</strong> e immetti il codice segreto: <strong>258069759</strong></p>
      <button id="obeyBtn">Ho Ubbidito, Signore delle Tenebre!</button>
      <div class="hidden-part" id="sacrificeBlock" style="display:none">
        <p><em>"Ogni rituale demoniaco, per essere portato a compimento ha bisogno di un sacrificio, chi sarà la tua vittima sacrificale?"</em></p>
        <p class="instr">"A mezzanotte (e solo a mezzanotte) nella Dark Room usa il comando <strong>/Sacrifica</strong> e nomina l'utente. Attenzione però, il malcapitato perderà la metà dei suoi punti esperienza!"</p>
      </div>
    </section>
  </main>

<script>
document.addEventListener('DOMContentLoaded', () => {
  /* ====== Parametri chiave ====== */
  const TARGET_SCORE = 10; // DEBUG — rimetti 666 quando vuoi

  /* Helper autoscroll */
  function autoScrollTo(el){
    if(!el) return;
    // aspetta che il layout si aggiorni e poi scrolla
    setTimeout(()=>{ el.scrollIntoView({behavior:'smooth', block:'start'}); }, 60);
  }

  /* HERO con fallback */
  const hero = document.getElementById('heroBox');
  const b = new Image(); b.src='media/home.png?v=1'; b.alt='Il Rituale';
  b.onload=()=>hero.appendChild(b);
  b.onerror=()=>{const fb=document.createElement('div');fb.className='hero-fallback';fb.textContent='MANCANTE: media/home.png';hero.appendChild(fb);};

  /* SIMBOLI */
  const SYMBOLS = Array.from({length:12},(_,i)=>({id:String(i+1),src:`./media/${i+1}.png?v=1`}));
  const TARGET = atob("MSwyLDMsNA==").split(","); // "1,2,3,4"
  const HINTS=[
    "Spesso gli oggetti dei rituali si nascondono nelle stanze più buie.",
    "Le scope delle streghe nascondono sempre qualcosa.",
    "Una volta ho sentito la storia di una \"casa del dolore\", forse si parlava di qualcosa di interessante?"
  ];
  document.getElementById('hintBox').textContent="Suggerimento: "+HINTS[Math.floor(Math.random()*HINTS.length)];

  const panel=document.getElementById('panel'), message=document.getElementById('message'),
        rituale=document.getElementById('rituale'), ritText=document.getElementById('ritText'),
        gameSec=document.getElementById('game'), epilogue=document.getElementById('epilogue');

  let state=[], ritualeShown=false;

  function renderSymbol(el,idx){
    el.innerHTML=''; const img=new Image(); img.src=SYMBOLS[idx].src; img.alt=`simbolo ${idx+1}`;
    img.onerror=()=>{el.innerHTML=`<div class="fallback">MANCANTE: ${SYMBOLS[idx].src}</div>`}; el.appendChild(img);
  }
  function createSlot(i){
    const wrap=document.createElement('div'); wrap.className='slot';
    const L=document.createElement('div'); L.className='arrow'; L.textContent='◀';
    const S=document.createElement('div'); S.className='symbol';
    const R=document.createElement('div'); R.className='arrow'; R.textContent='▶';
    wrap.append(L,S,R);
    state[i]=Math.floor(Math.random()*SYMBOLS.length); renderSymbol(S,state[i]);
    L.addEventListener('click',()=>{state[i]=(state[i]-1+SYMBOLS.length)%SYMBOLS.length;renderSymbol(S,state[i]);message.textContent='';});
    R.addEventListener('click',()=>{state[i]=(state[i]+1)%SYMBOLS.length;renderSymbol(S,state[i]);message.textContent='';});
    return wrap;
  }
  function build(){panel.innerHTML='';state=[];for(let i=0;i<4;i++)panel.appendChild(createSlot(i));}
  function shuffle(){for(let i=0;i<4;i++)state[i]=Math.floor(Math.random()*SYMBOLS.length);
    [...panel.children].forEach((slotEl,i)=>renderSymbol(slotEl.querySelector('.symbol'),state[i]));message.textContent='';}

  function check(){
    const picked=state.map(idx=>SYMBOLS[idx].id);
    const ok=picked.length===TARGET.length && picked.every((id,i)=>id===TARGET[i]);
    if(ok){
      message.className='msg success'; message.textContent='';
      if(!ritualeShown){
        ritText.textContent="Bene, molto bene. Quindi Herr Knock ti ha insegnato molto. Per procedere con il rituale è fondamentale trovare i tre ingredienti per Evocare il Principe delle Tenebre. Credo che tu possa trovarli all'interno del server, ma non sarà facile. Si tratta di tre oggetti, l'ordine non è importante (il Principe adora il caos) ma fai attenzione a nominarli in maniera corretta.";
        rituale.style.display='block';
        ritualeShown=true;
        autoScrollTo(rituale);
      }
    } else { message.className='msg fail'; message.textContent='sbagliato'; }
  }
  document.getElementById('shuffle').onclick=shuffle;
  document.getElementById('check').onclick=check;
  build();

  /* ===== RITUALE — validazione ingredienti e sblocco gioco ===== */
  const f1=document.getElementById('f1'), f2=document.getElementById('f2'), f3=document.getElementById('f3');
  const ritMsg=document.getElementById('ritMsg');
  function norm(s){return s.normalize('NFD').replace(/\p{Diacritic}/gu,'').toLowerCase().replace(/[^\p{L}\p{N}\s]/gu,'').replace(/\s+/g,' ').trim();}
  function classify(text){
    const v=norm(text); if(!v) return null;
    const has=(...ws)=>ws.every(w=>v.includes(w));
    if(v.includes('candela') && (v.includes('nera')||v.includes('nero'))) return 'CANDLE';
    const rust=v.includes('arrugginito')||v.includes('arrugginita')||v.includes('ossidato')||v.includes('ossidata')||v.includes('ruggine');
    if(v.includes('coltello') && rust && has('simbolo','bestia')) return 'KNIFE';
    const peli=v.includes('peli')||v.includes('pelo'); const pub=v.includes('pubici')||v.includes('pubico');
    const fem=v.includes('femmina')||v.includes('donna');
    if(peli && pub && v.includes('zombie') && fem) return 'HAIR';
    return null;
  }
  function submitRitual(){
    const types=[classify(f1.value), classify(f2.value), classify(f3.value)];
    const set=new Set(types.filter(Boolean));
    const ok=set.has('CANDLE') && set.has('KNIFE') && set.has('HAIR') && types.every(t=>t!==null);
    if(ok){
      ritMsg.className='rit-msg success';
      ritMsg.innerHTML='<strong>Il cerchio si illumina… il portale si apre!</strong><br>Dalle ombre convergono verso di te delle terrificanti creature, scappa da loro prima che ti rubino l\'anima e dimostra di essere degno!';
      gameSec.style.display='block';
      autoScrollTo(gameSec);
    }else{
      ritMsg.className='rit-msg fail';
      ritMsg.textContent='La formula non risponde. Forse hai sbagliato gli ingredienti...';
    }
  }
  document.getElementById('completeBtn').onclick=submitRitual;
  [f1,f2,f3].forEach(el=>el.addEventListener('keydown',e=>{ if(e.key==='Enter') submitRitual(); e.stopPropagation(); }));

  /* =========================
     MINIGIOCO — Pumpkin Runner (Responsive)
     ========================= */
  const BASE_W = 900, BASE_H = 300; // dimensioni logiche

  // Canvas & UI
  const cvs = document.getElementById('runner'), ctx = cvs.getContext('2d');
  const scoreHudEl = document.getElementById('scoreHud');
  const scoreEl = document.getElementById('score');
  const livesHud = document.getElementById('livesHud');
  const chargeFill = document.getElementById('chargeFill');
  const overlay = document.getElementById('overlayMsg'), overlayBox=document.getElementById('overlayBox');
  const startBtn = document.getElementById('startGame'),
        restartBtn = document.getElementById('restartGame'),
        loadingMsg = document.getElementById('loadingMsg');
  const wrap = document.getElementById('canvasWrap');

  // Immagini
  const playerImg = new Image(); playerImg.src = 'media/zucca.png?v=1';
  const heartImgSrc = 'media/heart.png';
  const bgImg = new Image(); bgImg.src = 'media/sfondo.png';
  const monsterNames = ['mostro1.png','mostro2.png','mostro3.png','mostro4.png'];
  const monsterImgs = monsterNames.map(n => { const im=new Image(); im.src='media/'+n+'?v=1'; return im; });

  function preload(imgs){
    const toLoad = imgs.filter(img => !img.complete || img.naturalWidth===0);
    if(toLoad.length===0) return Promise.resolve();
    return Promise.allSettled(toLoad.map(img => new Promise(res=>{
      img.addEventListener('load', res, {once:true});
      img.addEventListener('error', res, {once:true});
    })));
  }

  /* ---------- Stato/Costanti ---------- */
  let SCALE = 1;
  let running=false, gameOver=false, score=0, lastSpawn=0, lastTs=null;
  let cleared=false;

  // Velocità progressiva
  let speed = 0.8;
  let MAX_SPEED_BASE = 4.2;
  const SPEED_MULT_BASE = 1.10;
  const EXTRA_AFTER_300 = 1.30;
  const ACCEL_PER_SEC = 0.04;
  const ACCEL_RAMP_TIME = 90;
  let elapsedRunTime = 0;

  // Lanes
  let ground = 0, airLaneY = 0, midLaneY = 0;

  // Player
  const player = { x:120, y:0, w:44, h:44, vx:0, vy:0, onGround:true };

  // Oggetti
  const obstacles=[];   // {x,y,w,h,img,type,scale,baseX,baseY,oscA,oscT,oscP}
  const pickups=[];     // {x,y,w,h,type,emoji}
  const spawnQueue=[];  // {type, delay, scale}

  // Vite
  const MAX_LIVES = 3; let lives = MAX_LIVES; let invuln = 0;

  // Fisica + volo
  let GRAVITY = 0.52;
  let BASE_JUMP_VY = -11.0;
  let SHORT_CUT_VY = -3.0;
  const COYOTE_TIME = 0.14;
  const JUMP_BUFFER = 0.16;
  let coyoteTimer = 0, jumpBufferTimer = 0;

  let MOVE_ACCEL = 0.20;
  let MOVE_ACCEL_AIR = 0.12;
  let MAX_VX = 3.0;
  const FRICTION = 0.86;

  let FLIGHT_BOOST = 0.70;
  let FLIGHT_CLIMB_CAP = -4.2;
  const MAX_FLIGHT_ENERGY = 0.5;
  let FLIGHT_DRAIN = 0.6;
  let FLIGHT_RECHARGE = 0.06;
  let flightEnergy = MAX_FLIGHT_ENERGY;
  let FLIGHT_MIN_Y = 0;

  function updateChargeBar(){
    chargeFill.style.width = Math.round((flightEnergy / MAX_FLIGHT_ENERGY)*100) + '%';
  }

  // Effetti
  let shakeTime = 0;
  let effectTimer = 0, nextEffectAt = 10;
  let invertFilterTime = 0;
  let controlsInvertUntil = 0;
  const controlsInverted = ()=> performance.now()/1000 < controlsInvertUntil;

  /* ---------- Responsive ---------- */
  function calcBestScale(){
    const vw = window.innerWidth;
    const vh = window.innerHeight;
    const targetW = Math.max(600, Math.floor(vw * 0.98));
    const maxH = Math.floor(vh * 0.6);
    let s = targetW / BASE_W;
    let h = BASE_H * s;
    if(h > maxH){ s = maxH / BASE_H; }
    s = Math.max(0.8, Math.min(s, 3.0));
    return s;
  }
  function applyScale(newScale, keepPositions=true){
    const ratio = newScale / SCALE;
    SCALE = newScale;

    cvs.width = Math.round(BASE_W * SCALE);
    cvs.height = Math.round(BASE_H * SCALE);

    ground = cvs.height - Math.round(40 * SCALE);
    airLaneY = ground - Math.round(150 * SCALE);
    midLaneY = Math.round((ground + airLaneY)/2);

    MAX_SPEED_BASE = 4.2 * SCALE;
    speed = keepPositions ? speed * ratio : (0.8 * SCALE);

    GRAVITY = 0.52 * SCALE;
    BASE_JUMP_VY = -11.0 * SCALE;
    SHORT_CUT_VY = -3.0 * SCALE;
    MOVE_ACCEL = 0.20 * SCALE;
    MOVE_ACCEL_AIR = 0.12 * SCALE;
    MAX_VX = 3.0 * SCALE;

    FLIGHT_BOOST = 0.70 * SCALE;
    FLIGHT_CLIMB_CAP = -4.2 * SCALE;
    FLIGHT_MIN_Y = (airLaneY - (10 * SCALE)) - (44 * SCALE);

    if(keepPositions){
      player.x *= ratio; player.y *= ratio; player.w *= ratio; player.h *= ratio;
      player.vx *= ratio; player.vy *= ratio;
      obstacles.forEach(o=>{ o.x*=ratio; o.y*=ratio; o.w*=ratio; o.h*=ratio; o.baseX*=ratio; o.baseY*=ratio; o.oscA*=ratio; });
      pickups.forEach(p=>{ p.x*=ratio; p.y*=ratio; p.w*=ratio; p.h*=ratio; });
    } else {
      player.x = 120 * SCALE; player.w = 44 * SCALE; player.h = 44 * SCALE;
      player.y = ground - player.h; player.vx = 0; player.vy = 0; player.onGround = true;
    }
  }
  window.addEventListener('resize', ()=>applyScale(calcBestScale(), true));

  /* ---------- Disturbi ---------- */
  function maybeScheduleEffect(dt){
    if(score < 500) return;
    effectTimer += dt;
    if(effectTimer >= nextEffectAt){
      effectTimer = 0;
      nextEffectAt = 8 + Math.random()*6; // media ~10s
      if(Math.random() < 0.5){ shakeTime = 1.6; }
      else { invertFilterTime = 2.4; wrap.classList.add('invert'); }
    }
  }

  /* ---------- Spawn ostacoli ---------- */
  function drawImage(img, x,y,w,h){ if(img && img.complete && img.naturalWidth) ctx.drawImage(img,x,y,w,h); }

  function spawnObstacleNow(type, scale=1){
    const img = monsterImgs[Math.floor(Math.random()*monsterImgs.length)];
    const baseW = (46 + Math.random()*10) * SCALE;
    const w = baseW * scale;
    const ratio = (img && img.naturalWidth) ? (img.naturalHeight/img.naturalWidth) : 1.2;
    const h = w * ratio;

    let y;
    if(type==='ground'){ y = ground - h + (Math.random()*6 - 3) * SCALE; }
    else if(type==='air'){ y = airLaneY - h/2 + (Math.random()*12 - 6) * SCALE; }
    else { y = midLaneY - h/2 + (Math.random()*10 - 5) * SCALE; }

    obstacles.push({
      x:cvs.width+10, y, w, h, img, type, scale,
      baseX:cvs.width+10, baseY:y,
      oscA: (type==='air' ? (2 + Math.random()*4) : (type==='ground' ? (1 + Math.random()*2) : (1.5 + Math.random()*2.5))) * SCALE,
      oscT: 1.2 + Math.random()*0.8,
      oscP: Math.random()*Math.PI*2
    });
  }

  function shuffleArray(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j]]; } return a; }

  function queuePattern(currentScore){
    let minC=2, maxC=2;
    if(currentScore > 600){ minC=4, maxC=4; }
    else if(currentScore > 400){ minC=3, maxC=3; }

    let weights = {ground:0.62, mid:0.23, air:0.15};
    if(currentScore > 400) weights = {ground:0.58, mid:0.27, air:0.15};
    if(currentScore > 600) weights = {ground:0.55, mid:0.30, air:0.15};

    const count = Math.floor(Math.random()*(maxC-minC+1))+minC;

    function pickLane(){
      const r = Math.random();
      if(r < weights.ground) return 'ground';
      if(r < weights.ground + weights.mid) return 'mid';
      return 'air';
    }
    let types=[];
    for(let i=0;i<count;i++) types.push(pickLane());
    if(!types.includes('ground')) types[0] = 'ground';
    shuffleArray(types);

    const BASE_GAP = (0.22 + Math.random()*0.1);
    const JITTER = 0.14;
    const startOffset = Math.random()*0.3;
    const scaleBase = 0.9 + Math.min(0.3, currentScore/1000);

    types.forEach((t, idx)=>{
      const delay = startOffset + idx*BASE_GAP + (Math.random()*2*JITTER - JITTER);
      const scale = Math.max(0.8, Math.min(1.25, scaleBase + (Math.random()*0.2 - 0.1)));
      spawnQueue.push({type:t, delay: Math.max(0, delay), scale});
    });
  }

  /* ---------- Collezionabili ---------- */
  const PICKUP_CHANCE = 0.20;
  const PICKUP_COOLDOWN = 4.0;
  let lastPickupTime = -Infinity;

  function spawnPickup(){
    const now = performance.now() / 1000;
    if(now - lastPickupTime < PICKUP_COOLDOWN) return false;
    const pool = (score >= 500) ? ['candle','heart','bug'] : ['candle','heart'];
    const type = pool[Math.floor(Math.random()*pool.length)];
    const laneR = Math.random();
    const lane = laneR < 0.5 ? 'ground' : (laneR < 0.8 ? 'mid' : 'air');
    const emoji = type === 'candle' ? '🕯️' : (type === 'heart' ? '❤️' : '🐞');
    const fontSize = 24 * SCALE;
    const w = fontSize, h = fontSize;
    let y = ground - h - (6*SCALE);
    if(lane==='air') y = airLaneY - h/2;
    else if(lane==='mid') y = midLaneY - h/2;

    pickups.push({ x:cvs.width+10, y, w, h, emoji, type });
    lastPickupTime = now;
    return true;
  }

  function drawPickup(p){
    ctx.font = `${24*SCALE}px system-ui, Apple Color Emoji, Segoe UI Emoji, Noto Color Emoji`;
    ctx.textBaseline = "top";
    ctx.fillText(p.emoji, p.x, p.y);
  }

  /* ---------- Reset & End ---------- */
  function renderLives(){
    livesHud.innerHTML='';
    for(let i=0;i<MAX_LIVES;i++){
      const im = document.createElement('img');
      im.src = heartImgSrc;
      if(i >= lives){ im.style.filter='grayscale(1) brightness(0.7)'; im.style.opacity='0.5'; }
      livesHud.appendChild(im);
    }
  }

  function resetGame(){
    running=false; gameOver=false; score=0; lastTs=null; lastSpawn=0; cleared=false;
    overlay.style.display='none'; overlayBox.textContent='';
    obstacles.length=0; pickups.length=0; spawnQueue.length=0;

    elapsedRunTime=0; effectTimer=0; nextEffectAt=10;
    shakeTime=0; invertFilterTime=0; wrap.classList.remove('invert');
    controlsInvertUntil=0;

    flightEnergy = MAX_FLIGHT_ENERGY; updateChargeBar();

    applyScale(calcBestScale(), false);

    scoreHudEl.textContent='0'; scoreEl.textContent='0';
    invuln = 0; lives = MAX_LIVES; renderLives();
    cvs.classList.remove('blink');
  }

  function endGame(){
    gameOver = true; running = false;
    overlay.style.display='flex';
    const finalScore = Math.floor(score);
    if(cleared){
      overlayBox.style.color = 'var(--ok)';
      overlayBox.textContent = `Hai Ottenuto ${finalScore} Punti!`;
      document.getElementById('epilogue').style.display='block';
      autoScrollTo(document.getElementById('epilogue'));
    } else {
      overlayBox.style.color = 'var(--err)';
      overlayBox.textContent = 'Ritenta quante volte vuoi, tanto non ci riuscirai mai!';
    }
    document.getElementById('restartGame').style.display='inline-block';
    cvs.classList.remove('blink');
  }

  /* ---------- Danni ---------- */
  function hitPlayer(){
    if(invuln > 0 || gameOver) return;
    lives -= 1; renderLives();
    invuln = 1.2;
    cvs.classList.add('blink');
    if(lives <= 0){ endGame(); }
  }

  /* ---------- Loop ---------- */
  let timeSec = 0, bgOffset = 0;

  function drawBackground(){
    if(bgImg && bgImg.complete && bgImg.naturalWidth){
      const bw = bgImg.naturalWidth, bh = bgImg.naturalHeight;
      const scale = cvs.height / bh, drawW = bw * scale;
      bgOffset = (bgOffset - (speed * 0.42)) % drawW;
      if(bgOffset < -drawW) bgOffset += drawW;
      for(let x=bgOffset; x < cvs.width + drawW; x += drawW){
        ctx.drawImage(bgImg, 0, 0, bw, bh, Math.floor(x), 0, Math.ceil(drawW), cvs.height);
      }
    } else {
      const g = ctx.createLinearGradient(0,0,0,cvs.height);
      g.addColorStop(0,'#020202'); g.addColorStop(1,'#0a0a0a');
      ctx.fillStyle=g; ctx.fillRect(0,0,cvs.width,cvs.height);
    }
  }

  function loop(ts){
    if(!running) return;
    const delta = lastTs ? (ts-lastTs)/1000 : 0; lastTs = ts;
    timeSec += delta;
    elapsedRunTime += delta;

    // velocità con rampa
    const t = Math.min(1, elapsedRunTime / ACCEL_RAMP_TIME);
    const eased = t*t*(3 - 2*t);
    const baseTarget = (0.8 * SCALE) + ((4.2 * SCALE) - (0.8 * SCALE)) * eased;
    const mult = (score >= 300) ? (SPEED_MULT_BASE * EXTRA_AFTER_300) : SPEED_MULT_BASE;
    const targetSpeed = baseTarget * mult;
    speed += (targetSpeed - speed) * ACCEL_PER_SEC;

    // punteggio & clear
    score += (1.1 + ((speed - (0.8*SCALE))/SCALE)*0.22) * delta;
    const shown = Math.floor(score);
    scoreHudEl.textContent = shown;
    scoreEl.textContent = shown;
    if(!cleared && score >= TARGET_SCORE){ cleared = true; }

    // effetti
    maybeScheduleEffect(delta);
    if(invertFilterTime > 0){ invertFilterTime -= delta; if(invertFilterTime <= 0){ wrap.classList.remove('invert'); } }
    if(shakeTime > 0) shakeTime -= delta;

    ctx.save();
    if(shakeTime > 0){
      const s = 2.5 * SCALE;
      const ox = (Math.random()*2-1)*s;
      const oy = (Math.random()*2-1)*s;
      ctx.translate(ox, oy);
    }

    drawBackground();

    // linee corsie
    ctx.strokeStyle='rgba(43,255,136,.3)';
    ctx.beginPath(); ctx.moveTo(0,ground+0.5); ctx.lineTo(cvs.width,ground+0.5); ctx.stroke();
    ctx.setLineDash([6*SCALE,6*SCALE]);
    ctx.beginPath(); ctx.moveTo(0,midLaneY+0.5); ctx.lineTo(cvs.width,midLaneY+0.5); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0,airLaneY+0.5); ctx.lineTo(cvs.width,airLaneY+0.5); ctx.stroke();
    ctx.setLineDash([]);

    // spawn clock
    const baseInterval = 2400 - (speed/SCALE)*90;
    const jitter = 900 * Math.random();
    const interval = Math.max(1400, baseInterval + jitter);

    if(ts - lastSpawn > interval){
      lastSpawn = ts;
      if(!cleared && Math.random() < PICKUP_CHANCE){
        if(!spawnPickup()){ queuePattern(score); }
      } else {
        queuePattern(score);
      }
    }

    // esegui coda sfalsata
    for(let i=spawnQueue.length-1;i>=0;i--){
      spawnQueue[i].delay -= delta;
      if(spawnQueue[i].delay <= 0){
        spawnObstacleNow(spawnQueue[i].type, spawnQueue[i].scale ?? 1);
        spawnQueue.splice(i,1);
      }
    }

    // pickups
    for(let i=pickups.length-1;i>=0;i--){
      const p = pickups[i];
      p.x -= speed;
      drawPickup(p);
      if(p.x + p.w < 0){ pickups.splice(i,1); continue; }
      const padP = 8*SCALE, padO = 4*SCALE;
      const px=player.x+padP, py=player.y+padP, pw=player.w-2*padP, ph=player.h-2*padP;
      const ox=p.x+padO, oy=p.y+padO, ow=p.w-2*padO, oh=p.h-2*padO;
      if(px < ox + ow && px + pw > ox && py < oy + oh && py + ph > oy){
        if(p.type === 'candle'){ score += 50; }
        else if(p.type === 'heart'){ if(lives < MAX_LIVES){ lives += 1; renderLives(); } }
        else if(p.type === 'bug'){ controlsInvertUntil = performance.now()/1000 + 5; }
        pickups.splice(i,1);
      }
    }

    // ostacoli (oscillazioni dopo 300)
    for(let i=obstacles.length-1;i>=0;i--){
      const o=obstacles[i];
      o.baseX -= speed;
      let drawX = o.baseX;
      let drawY = o.baseY;
      if(score >= 300){
        const phase = (timeSec + o.oscP) * (2*Math.PI / o.oscT);
        if(o.type === 'air')      drawY = o.baseY + Math.sin(phase) * o.oscA;
        else if(o.type === 'ground') drawX = o.baseX + Math.sin(phase) * (o.oscA*0.8);
        else                      drawY = o.baseY + Math.sin(phase) * (o.oscA*0.6);
      }
      o.x = drawX; o.y = drawY;

      drawImage(o.img, o.x, o.y, o.w, o.h);
      if(o.x + o.w < 0) obstacles.splice(i,1);

      const padP = 10*SCALE, padO = 12*SCALE;
      const px=player.x+padP, py=player.y+padP, pw=player.w-2*padP, ph=player.h-2*padP;
      const ox=o.x+padO, oy=o.y+padO, ow=o.w-2*padO, oh=o.h-2*padO;
      if(px < ox + ow && px + pw > ox && py < oy + oh && py + ph > oy){ hitPlayer(); }
    }

    /* --- Fisica player --- */
    const leftActive  = controlsInverted() ? keys.right : keys.left;
    const rightActive = controlsInverted() ? keys.left  : keys.right;

    const accel = player.onGround ? MOVE_ACCEL : MOVE_ACCEL_AIR;
    if(leftActive && !rightActive)  player.vx -= accel;
    else if(rightActive && !leftActive) player.vx += accel;
    else player.vx *= FRICTION;
    player.vx = Math.max(-MAX_VX, Math.min(MAX_VX, player.vx));

    player.x += player.vx;
    const minX = 20*SCALE, maxX = cvs.width * 0.7;
    if(player.x < minX){ player.x = minX; player.vx = Math.max(0, player.vx); }
    if(player.x > maxX){ player.x = maxX; player.vx = Math.min(0, player.vx); }

    // gravità
    player.vy += GRAVITY;

    // volo
    if(keys.up && !player.onGround && flightEnergy > 0){
      player.vy -= FLIGHT_BOOST;
      if(player.vy < FLIGHT_CLIMB_CAP) player.vy = FLIGHT_CLIMB_CAP;
      flightEnergy = Math.max(0, flightEnergy - FLIGHT_DRAIN * delta);
      updateChargeBar();
    } else {
      flightEnergy = Math.min(MAX_FLIGHT_ENERGY, flightEnergy + FLIGHT_RECHARGE * delta);
      updateChargeBar();
    }

    player.y += player.vy;

    // limiti verticali (massimo fino poco sopra la corsia alta)
    const topLimit = Math.min(FLIGHT_MIN_Y, 2);
    if(player.y < topLimit){
      player.y = topLimit;
      if(player.vy < 0) player.vy = 0;
    }

    // atterraggio & coyote
    if(player.y + player.h >= ground){
      player.y = ground - player.h;
      if(!player.onGround){ player.onGround = true; coyoteTimer = 0; tryPerformJump(); }
      if(player.vy > 0) player.vy = 0;
    } else {
      if(player.onGround){ player.onGround = false; coyoteTimer = COYOTE_TIME; }
      else { coyoteTimer -= delta; }
    }

    // salto variabile
    if(!keys.jumpHeld && player.vy < SHORT_CUT_VY){ player.vy = SHORT_CUT_VY; }

    // timers
    jumpBufferTimer -= delta;
    invuln -= delta;
    if(invuln <= 0){ invuln = 0; cvs.classList.remove('blink'); }

    // draw player
    if(!(invuln>0 && Math.floor(ts/60)%2===0)){
      drawImage(playerImg, player.x, player.y, player.w, player.h);
    }

    ctx.restore();
    requestAnimationFrame(loop);
  }

  /* ---------- Input ---------- */
  const keys = { left:false, right:false, up:false, jumpHeld:false };
  function requestJump(){ jumpBufferTimer = JUMP_BUFFER; }
  function doDirectionalJump(){
    let vy = BASE_JUMP_VY;
    let impulseX = 0;
    const leftActive  = controlsInverted() ? keys.right : keys.left;
    const rightActive = controlsInverted() ? keys.left  : keys.right;

    if(rightActive && !leftActive){ vy = BASE_JUMP_VY * 1.05; impulseX = 2.8 * SCALE; }
    else if(leftActive && !rightActive){ vy = BASE_JUMP_VY * 0.62; impulseX = -2.1 * SCALE; }

    player.vy = vy;
    player.vx = Math.max(-MAX_VX, Math.min(MAX_VX, player.vx + impulseX));
    player.onGround = false;
    coyoteTimer = 0; jumpBufferTimer = 0;
  }
  function tryPerformJump(){
    if ((coyoteTimer > 0 || player.onGround) && jumpBufferTimer > 0) doDirectionalJump();
  }

  window.addEventListener('keydown', async (e)=>{
    const tag=document.activeElement && document.activeElement.tagName;
    if(tag==='INPUT' || tag==='TEXTAREA') return;

    if(e.code==='ArrowLeft'){ keys.left = true; }
    if(e.code==='ArrowRight'){ keys.right = true; }
    if(e.code==='ArrowUp'){ keys.up = true; }

    if(e.code==='Space' || e.code==='ArrowUp'){
      e.preventDefault();
      if(gameOver){ resetGame(); await startGame(); return; }
      keys.jumpHeld = true;
      if(!running){ await startGame(); requestJump(); }
      else { requestJump(); tryPerformJump(); }
    }
  });
  window.addEventListener('keyup', (e)=>{
    if(e.code==='ArrowLeft'){ keys.left = false; }
    if(e.code==='ArrowRight'){ keys.right = false; }
    if(e.code==='ArrowUp'){ keys.up = false; keys.jumpHeld = false; }
    if(e.code==='Space'){ keys.jumpHeld = false; }
  });

  // Touch/click
  cvs.addEventListener('pointerdown', ()=>{
    if(gameOver){ resetGame(); startGame(); return; }
    if(!running){ startGame(); requestJump(); }
    else { keys.jumpHeld = true; keys.up = true; requestJump(); tryPerformJump(); }
  });
  cvs.addEventListener('pointerup', ()=>{ keys.jumpHeld=false; keys.up=false; });

  /* ---------- Avvio gioco ---------- */
  async function startGame(){
    loadingMsg.style.display='block';
    await preload([playerImg, bgImg, ...monsterImgs]);
    loadingMsg.style.display='none';
    if(!running){
      running = true; document.getElementById('restartGame').style.display='none'; requestAnimationFrame(loop);
    }
  }
  document.getElementById('startGame').onclick = startGame;
  document.getElementById('restartGame').onclick = ()=>{ resetGame(); startGame(); };

  /* Epilogo: mostra la parte del sacrificio al click (con autoscroll) */
  document.getElementById('obeyBtn').addEventListener('click', ()=>{
    const sb=document.getElementById('sacrificeBlock');
    if(sb){ sb.style.display='block'; autoScrollTo(sb); }
  });

  /* Inizializzazione */
  applyScale(calcBestScale(), false);
  renderLives(); updateChargeBar();
});
</script>
</body>
</html>
